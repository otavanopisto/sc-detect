{
  "version": 3,
  "sources": ["../js/tokenizer.ts", "../js/ai.ts", "../js/watchdog.ts", "../js/index.ts"],
  "sourcesContent": ["const SIMPLE_TOKENIZER_CACHE: { [key: string]: string[] } = {};\r\nconst SIMPLE_TOKENIZER_CACHE_TIMEOUTS : { [key: string]: any } = {};\r\n\r\nexport function simpleTokenizer(input: string): string[] {\r\n    if (SIMPLE_TOKENIZER_CACHE[input]) {\r\n        clearTimeout(SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input]);\r\n        SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n            delete SIMPLE_TOKENIZER_CACHE[input];\r\n            delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n        }, 60000); // Cache timeout of 60 seconds\r\n        return SIMPLE_TOKENIZER_CACHE[input];\r\n    }\r\n\r\n    const tokens: string[] = [];\r\n    let currentToken = '';\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n        const char = input[i];\r\n\r\n        if (/\\s/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n        } else if (/[.,!?;:()]/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n            tokens.push(char);\r\n        } else {\r\n            currentToken += char;\r\n        }\r\n    }\r\n\r\n    if (currentToken) {\r\n        tokens.push(currentToken);\r\n    }\r\n\r\n    SIMPLE_TOKENIZER_CACHE[input] = tokens.map((token) => normalizeToken(token)).filter((token) => token.length > 0);\r\n\r\n    SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n        delete SIMPLE_TOKENIZER_CACHE[input];\r\n        delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n    }, 60000); // Cache timeout of 60 seconds\r\n\r\n    return SIMPLE_TOKENIZER_CACHE[input];\r\n}\r\n\r\n// it should normalize tokens for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\nfunction normalizeToken(token: string): string {\r\n    const accentsMap: { [key: string]: string } = {\r\n        '\u00E1': 'a',\r\n        '\u00E9': 'e',\r\n        '\u00ED': 'i',\r\n        '\u00F3': 'o',\r\n        '\u00FA': 'u',\r\n        '\u00F1': 'n',\r\n        '\u00E4': 'a',\r\n        '\u00F6': 'o',\r\n        '\u00FC': 'u',\r\n    };\r\n\r\n    // normalize common prefixes and suffixes for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\n    const commonPrefixes = ['un', 're', 'in', 'im', 'dis', 'en', 'non', 'non-', 'pre', 'pre-', 'mis', 'sub', 'inter', 'fore', 'de', 'trans', 'super', 'semi', 'anti', 'mid', 'under'];\r\n    const commonSuffixes = ['s', 'es', 'ed', 'ing', 'ly', 'er', 'or', 'ion', 'tion', 'ation', 'ity', 'ment', 'ness', 'ful', 'less', 'est', 'ive', 'y', 'ize', 'ise', 'ify', 'en', 'ssa', 'lla', 'aa'];\r\n\r\n    for (const prefix of commonPrefixes) {\r\n        if (token.startsWith(prefix)) {\r\n            token = token.replace(prefix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    for (const suffix of commonSuffixes) {\r\n        if (token.endsWith(suffix)) {\r\n            token = token.replace(suffix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    return token\r\n        .toLowerCase()\r\n        .replace(/[\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1\u00E4\u00F6\u00FC]/g, (match) => accentsMap[match] || match);\r\n}\r\n\r\n/**\r\n * Checks how similar two token arrays are and gives a score between 0 and 1.\r\n * @param tokensA \r\n * @param tokensB \r\n * @returns \r\n */\r\nexport function tokenSimilarityCompare(tokensA: string[], tokensB: string[]): number {\r\n    const setA = new Set(tokensA);\r\n    const setB = new Set(tokensB);\r\n\r\n    const intersection = new Set([...setA].filter(x => setB.has(x)));\r\n    const union = new Set([...setA, ...setB]);\r\n\r\n    return intersection.size / union.size;\r\n}\r\n\r\n/**\r\n * Checks what proportion of tokens in tokensContained are also in tokensContainer and gives a score between 0 and 1.\r\n * @param tokensContainer \r\n * @param tokensContained \r\n */\r\nexport function tokenContainmentCompare(tokensContainer: string[], tokensContained: string[]): number {\r\n    const setContainer = new Set(tokensContainer);\r\n    const setContained = new Set(tokensContained);\r\n\r\n    const intersection = new Set([...setContained].filter(x => setContainer.has(x)));\r\n\r\n    return intersection.size / setContained.size;\r\n}\r\n\r\nexport function tokenIncludesScore(tokensContainer: string[], tokensContained: string[], minimum_relevant: number): number {\r\n    // we need to look for exact sequences of tokensContained in tokensContainer in the same order as well as potential fragments\r\n    let score = 0;\r\n    // we will iterate over tokensContained to check each token as if it is found\r\n    for (let i = 0; i <= tokensContained.length - tokensContained.length; i++) {\r\n        // find the token in tokensContainer\r\n        let thisTokenMaxScoreSoFar = 0;\r\n        // now we will iterate over tokensContainer to find matches\r\n        for (let j = 0; j <= tokensContainer.length - tokensContained.length; j++) {\r\n            // check if tokensContainer[j] matches tokensContained[i]\r\n            if (tokensContainer[j] === tokensContained[i]) {\r\n                // now we need to see how many tokens match in sequence from this point\r\n                // we will calculate a score for this token match based on how many tokens match in sequence\r\n                let thisTokenScoreAtThisLocation = 0;\r\n                // we found a match, now let's check if the token is surrounded by the tokens before and after it that match as well\r\n                let matchLength = 0;\r\n                let matchMax = 0\r\n                // check backwards and forwards, seeing how well the surrounding tokens match\r\n                for (let k = -i; k < tokensContained.length - i; k++) {\r\n                    // the further away we go, the less weight it has, so we add a fraction of 1 based on how far we are from the center\r\n                    const potentialScoreAdded = 1 - (Math.abs(k) / tokensContained.length);\r\n                    matchMax += potentialScoreAdded;\r\n                    if (tokensContainer[j + k] === tokensContained[i + k]) {\r\n                        matchLength += potentialScoreAdded\r\n                    }\r\n                }\r\n\r\n                // calculate score for this token at this location\r\n                thisTokenScoreAtThisLocation = matchLength / matchMax;\r\n                \r\n                // see if it's the best score for this token so far\r\n                // use a max function to keep the best score\r\n                if (thisTokenScoreAtThisLocation > thisTokenMaxScoreSoFar) {\r\n                    thisTokenMaxScoreSoFar = thisTokenScoreAtThisLocation;\r\n                }\r\n            }\r\n        }\r\n\r\n        // add the best score for this token to the total score\r\n        score += thisTokenMaxScoreSoFar;\r\n    }\r\n\r\n    // average the score over the number of tokens contained\r\n    const finalScore = score / tokensContained.length;\r\n\r\n    // check if the final score is above the minimum relevant threshold\r\n    if (finalScore >= minimum_relevant) {\r\n        return finalScore;\r\n    }\r\n\r\n    return 0;\r\n}", "export function findAISignatures(text: string, treshold: number = 1): number {\r\n    // find ai signatures in the text that suggest it was generated by an ai language model\r\n    // for example em dashes\r\n    // emojis in the text\r\n    // certain phrases like \"as an ai language model\"\r\n    // numeration styles like \"1.\", \"2.\", \"3.\"\r\n    let score = 0;\r\n    const emDashCount = (text.match(/\u2014/g) || []).length;\r\n    score += emDashCount * 0.3;\r\n\r\n    // find emojis\r\n    const emojiCount = (text.match(/[\\u{1F600}-\\u{1F64F}]/gu) || []).length;\r\n    score += emojiCount * 0.5;\r\n\r\n    // find phrases\r\n    const aiPhrases = [\r\n        'as an ai language model',\r\n        'i am an ai',\r\n        'i am an artificial intelligence',\r\n        'as an artificial intelligence',\r\n    ];\r\n    for (const phrase of aiPhrases) {\r\n        const phraseCount = (text.toLowerCase().match(new RegExp(phrase, 'g')) || []).length;\r\n        score += phraseCount * 1;\r\n    }\r\n\r\n    // find numeration styles\r\n    const numerationCount = (text.match(/\\b\\d+\\./g) || []).length;\r\n    score += numerationCount * 0.05;\r\n\r\n    if (score > treshold) {\r\n        return 1\r\n    }\r\n    return 0;\r\n}", "import { simpleTokenizer, tokenContainmentCompare, tokenIncludesScore, tokenSimilarityCompare } from \"./tokenizer\";\r\nimport { findAISignatures } from \"./ai\";\r\n\r\n/**\r\n * Watchdog module to monitor copy-paste behavior and tab switching\r\n * to detect potential cheating\r\n * \r\n * weights:\r\n *  - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: weight for the factor that measures\r\n *    how much the user keeps switching tabs and copy-pasting\r\n *  - COPY_RELATES_TO_PASTE: weight for the factor that measures how much\r\n *   the copy events relate to the paste events\r\n *  - CONTENT_CONTAINS_AI_SIGNATURES: weight for the factor that measures\r\n *   how much the content contains AI signatures\r\n *  - UNMODIFIED_PASTES: weight for the factor that measures how much\r\n *  the pastes are unmodified\r\n * \r\n * min_copy_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * min_tab_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * \r\n * Keep the weights summing to 1.0 in order to have a proper confidence score\r\n * between 0 and 1.0\r\n * \r\n * Note that a confidence score close to 1.0 does not necessarily mean cheating,\r\n * but rather a high likelihood of cheating behavior based on the monitored factors.\r\n * A human review is still recommended for high confidence scores.\r\n * \r\n * paste_size_threshold: minimum size of pasted content to consider\r\n * copy_size_threshold: minimum size of copied content to consider\r\n * settings:\r\n *  - relevant_copy_event_minutes: time window in minutes to consider\r\n *    copy events as relevant to paste events\r\n *  - relevant_tab_in_out_event_minutes: time window in minutes to consider\r\n *    tab in/out events as relevant to copy-paste behavior\r\n */\r\nexport interface WatchdogConfig {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number,\r\n            COPY_RELATES_TO_PASTE: number,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: number,\r\n            UNMODIFIED_PASTES: number,\r\n        },\r\n        min_copy_event_time_weight: number,\r\n        min_tab_event_time_weight: number,\r\n    },\r\n    paste_size_threshold: number,\r\n    copy_size_threshold: number,\r\n    settings: {\r\n        relevant_copy_event_minutes: number;\r\n        relevant_tab_in_out_event_minutes: number;\r\n    }\r\n}\r\n\r\n/**\r\n * The default configuration for the Watchdog module\r\n */\r\nconst DEFAULT_CONFIG: WatchdogConfig = {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0.3,\r\n            COPY_RELATES_TO_PASTE: 0.3,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0.2,\r\n            UNMODIFIED_PASTES: 0.1,\r\n        },\r\n        min_copy_event_time_weight: 0.5,\r\n        min_tab_event_time_weight: 0.5,\r\n    },\r\n    paste_size_threshold: 100,\r\n    copy_size_threshold: 30,\r\n    settings: {\r\n        relevant_copy_event_minutes: 5,\r\n        relevant_tab_in_out_event_minutes: 5,\r\n    }\r\n}\r\n\r\n/**\r\n * Factors that influence the Watchdog analysis\r\n * - deadline: time remaining until the deadline in minutes, if zero or negative, no deadline\r\n * - caught_rate: rate of previous cheating detections for the user, between 0 and 1\r\n * - non_native_language: whether the user is using a non-native language for the test\r\n */\r\nexport interface WatchdogFactors {\r\n    deadline: number,\r\n    caught_rate: number,\r\n    non_native_language: boolean,\r\n}\r\n\r\n/**\r\n * The default factors for the Watchdog module\r\n * - deadline: 0 (no deadline)\r\n * - caught_rate: 0 (no previous cheating detections)\r\n * - non_native_language: false (native language)\r\n */\r\nconst DEFAULT_FACTORS: WatchdogFactors = {\r\n    deadline: 0,\r\n    caught_rate: 0,\r\n    non_native_language: false,\r\n}\r\n\r\n/**\r\n * Interface for copy-paste contribution objects\r\n */\r\nexport interface CopyPasteContribution {\r\n    /**\r\n     * AI signature score for the pasted content, a number between 0 and 1 on whether the content has AI signatures\r\n     */\r\n    aiScore: number;\r\n    /**\r\n     * Cheating paste score based on similarity and related copy/tab switch events, a number between 0 and 1\r\n     */\r\n    pasteScore: number;\r\n    /**\r\n     * Final score for this contribution, a number between 0 and 1, the maximum between aiScore and pasteScore\r\n     */\r\n    score: number;\r\n    /**\r\n     * Timestamp of the paste event\r\n     */\r\n    timestamp: Date;\r\n    /**\r\n     * Similarity between copied and pasted content, a number between 0 and 1\r\n     */\r\n    similarity: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the content of the tokens, a number between 0 and 1\r\n     */\r\n    containment: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the time and tab switching, a number between 0 and 1\r\n     */\r\n    copyFactor: number;\r\n    /**\r\n     * Factor how much a paste is related to a tab switch event, based on the time, a number between 0 and 1\r\n     */\r\n    tabSwitchFactor: number;\r\n    /**\r\n     * Content of the pasted text\r\n     */\r\n    content: string;\r\n}\r\n\r\n/**\r\n * State interface for each WatchdogHandle, each one represents a monitored input element or textarea\r\n * - COPY_PASTE_CONTRIBUTIONS: array of copy-paste contribution objects\r\n * - COPY_RELATES_TO_PASTE: score for the factor that measures how much copy events relate to paste events\r\n * - CONTENT_CONTAINS_AI_SIGNATURES: score for the factor that measures how much the content contains AI signatures\r\n * - UNMODIFIED_PASTES: score for the factor that measures how much the pastes are unmodified\r\n * - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: score for the factor that measures how much the user keeps switching tabs and copy-pasting\r\n * \r\n * All factors are between 0 and 1, the final confidence score is calculated\r\n * by weighting each factor according to the weights defined in the WatchdogConfig\r\n */\r\nexport interface WatchdogHandleState {\r\n    COPY_PASTE_CONTRIBUTIONS: Array<CopyPasteContribution>;\r\n    COPY_RELATES_TO_PASTE: number;\r\n    CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n    UNMODIFIED_PASTES: number;\r\n    KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n}\r\n\r\nexport type WatchdogStateLoader = () => Promise<WatchdogHandleState>;\r\n\r\nclass WatchdogHandle {\r\n    element: HTMLElement;\r\n    watchdog: Watchdog;\r\n    isInitialized: boolean = false;\r\n    state: WatchdogHandleState;\r\n    loadStateLoader: WatchdogStateLoader | null = null;\r\n\r\n    constructor(element: HTMLElement, watchdog: Watchdog) {\r\n        this.element = element;\r\n        this.watchdog = watchdog;\r\n        this.state = {\r\n            COPY_PASTE_CONTRIBUTIONS: [],\r\n            // INPUT_CONTRIBUTIONS: [],\r\n\r\n            COPY_RELATES_TO_PASTE: 0,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0,\r\n            UNMODIFIED_PASTES: 0,\r\n        };\r\n\r\n        this.handlePaste = this.handlePaste.bind(this);\r\n        // this.handleInput = this.handleInput.bind(this);\r\n    }\r\n    setStateLoader(fn: WatchdogStateLoader) {\r\n        this.loadStateLoader = fn;\r\n    }\r\n    async initialize() {\r\n        if (!this.watchdog.isMonitoring) {\r\n            throw new Error('Watchdog is not initialized. Please call scDetect.initialize() first.');\r\n        }\r\n        this.isInitialized = true;\r\n        // make sure that is in an input with contenteditable or textarea or input type=text\r\n        const tagName = this.element.tagName.toLowerCase();\r\n        const type = (this.element as HTMLInputElement).type;\r\n        if (tagName === 'textarea' || (tagName === 'input' && type === 'text') || this.element.isContentEditable) {\r\n            // Start monitoring the element for copy-paste and tab switch events\r\n            // Implementation of monitoring logic goes here\r\n            await this.loadState();\r\n            this.restart();\r\n        } else {\r\n            throw new Error('Element is not a valid input field (textarea, input type=text, or contenteditable).');\r\n        }\r\n    }\r\n    async loadState() {\r\n        // Implementation of loadState method for this handle\r\n        // Load any saved state from this.state\r\n        if (this.loadStateLoader) {\r\n            this.state = await this.loadStateLoader();\r\n        }\r\n\r\n        // TODO other loading mechanisms can be added here\r\n    }\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    restart() {\r\n        if (!this.isInitialized) {\r\n            throw new Error('WatchdogHandle is not initialized. Please call initialize() first.');\r\n        }\r\n        // Implementation of restart method for this handle\r\n        // add event listeners to paste, input\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput);\r\n        this.element.addEventListener('paste', this.handlePaste);\r\n        this.element.addEventListener('input', this.handleInput);\r\n    }\r\n    stop() {\r\n        // Implementation of stop method for this handle\r\n        this.isInitialized = false;\r\n\r\n        // remove all event listeners\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput);\r\n    }\r\n    destroy() {\r\n        // Implementation of destroy method for this handle\r\n        this.stop();\r\n        // Additional cleanup\r\n        this.watchdog.handles = this.watchdog.handles.filter(h => h !== this);\r\n    }\r\n    handleInput(e: Event) {\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n    }\r\n    handlePaste(e: ClipboardEvent) {\r\n        const clipboardData = e.clipboardData;\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n        const text = clipboardData.getData('text/plain');\r\n\r\n        if (!text) {\r\n            return;\r\n        }\r\n\r\n        // check if it fits the paste size threshold\r\n        if (text.length < this.watchdog.config.paste_size_threshold) {\r\n            return;\r\n        }\r\n\r\n        const tokens = simpleTokenizer(text);\r\n        const similarity = tokenSimilarityCompare(tokens, this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : []);\r\n        const containment = tokenContainmentCompare(this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : [], tokens);\r\n\r\n        // similarities too high are likely modified pastes, so we just ignore them\r\n        if (similarity > 0.9) {\r\n            return;\r\n        }\r\n\r\n        // Now lets look for a copy event, followed by a tabout event, followed by this paste event\r\n        // within a reasonable time frame (e.g., 5 minutes)\r\n        const now = new Date();\r\n        let foundRelatedCopy = false;\r\n        let foundRelatedCopyTimeFactor = 0;\r\n        let switchedTabsRecently = false;\r\n        let switchedTabsRecentlyTimeFactor = 0;\r\n\r\n        if (this.watchdog.lastCopiedInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.lastCopiedInfo.timestamp.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000) {\r\n                foundRelatedCopy = true;\r\n                foundRelatedCopyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000));\r\n                if (foundRelatedCopyTimeFactor < this.watchdog.config.weights.min_copy_event_time_weight) {\r\n                    foundRelatedCopyTimeFactor = this.watchdog.config.weights.min_copy_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.watchdog.activeTabFocusInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.activeTabFocusInfo.focused_in.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000) {\r\n                switchedTabsRecently = true;\r\n                switchedTabsRecentlyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000));\r\n                if (switchedTabsRecentlyTimeFactor < this.watchdog.config.weights.min_tab_event_time_weight) {\r\n                    switchedTabsRecentlyTimeFactor = this.watchdog.config.weights.min_tab_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        const foundRelatedCopyFactor = (foundRelatedCopy ? 1 : 0) * foundRelatedCopyTimeFactor;\r\n        const switchedTabsRecentlyFactor = (switchedTabsRecently ? 1 : 0) * switchedTabsRecentlyTimeFactor;\r\n        // the cheating paste score is the average of the three factors\r\n        // we weight equally the containment, as in if the pasted content relates to copied content and by how much it relates\r\n        // and the foundRelatedCopyFactor and switchedTabsRecentlyFactor, which are time-weighted factors indicating recent related copy and tab switch events\r\n        const cheatingPasteScore = (containment + foundRelatedCopyFactor + switchedTabsRecentlyFactor) / 3;\r\n        let score = cheatingPasteScore;\r\n\r\n        // we also check for AI signatures in the pasted content\r\n        const aiScore = findAISignatures(text, 1);\r\n\r\n        // if aiScore is higher than cheatingPasteScore, we use that as the score\r\n        if (aiScore >= cheatingPasteScore) {\r\n            score = aiScore;\r\n        }\r\n\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.push({\r\n            pasteScore: cheatingPasteScore,\r\n            score: score,\r\n            aiScore: aiScore,\r\n            timestamp: now,\r\n            similarity: similarity,\r\n            containment: containment,\r\n            copyFactor: foundRelatedCopyFactor,\r\n            tabSwitchFactor: switchedTabsRecentlyFactor,\r\n            content: text,\r\n        });\r\n\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n    }\r\n    private recalculateCopyRelatesToPaste() {\r\n        // calculate average score, guarding against empty contributions array\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.COPY_RELATES_TO_PASTE = 0;\r\n        } else {\r\n            // we average the scores of all contributions\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.score;\r\n            })\r\n            this.state.COPY_RELATES_TO_PASTE = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateAIScore() {\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = 0;\r\n        } else {\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.aiScore;\r\n            })\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateUnmodifiedPastes() {\r\n        // recalculate unmodified pastes factor\r\n        let unmodifiedPastes = 0;\r\n        const totalPastes = this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n\r\n        if (totalPastes === 0) {\r\n            this.state.UNMODIFIED_PASTES = 0;\r\n            return;\r\n        }\r\n\r\n        let contentWorking = this.getContentFromHTMLElement();\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n            if (contentWorking.includes(contribution.content)) {\r\n                unmodifiedPastes++;\r\n                // remove the pasted content from the working content to avoid double counting\r\n                contentWorking = contentWorking.replace(contribution.content, '');\r\n            }\r\n        });\r\n\r\n        const unmodifiedPastesRatio = unmodifiedPastes / totalPastes;\r\n        const remainingCharacters = contentWorking.length;\r\n        const totalCharacters = this.getContentFromHTMLElement().length;\r\n        const remainingCharactersRatio = totalCharacters > 0 ? remainingCharacters / totalCharacters : 0;\r\n\r\n        // combine both ratios to get a final unmodified pastes score\r\n        const finalUnmodifiedPastesScore = (unmodifiedPastesRatio + (1 - remainingCharactersRatio)) / 2;\r\n\r\n        this.state.UNMODIFIED_PASTES = finalUnmodifiedPastesScore;  \r\n    }\r\n    private recalculateKeepsSwitchingTabsAndCopyPasting() {\r\n        // recalculate keeps switching tabs and copy pasting factor\r\n        // for that we will look for an ever alternating pattern of tab switches followed by a paste event\r\n        let switchingTabAndCopyPastingScore = 0;\r\n        let totalPatterns = 0;\r\n\r\n        // first let's loop in the tab focus history to find tab switches\r\n        const tabFocusHistoryWithCurrent: TabFocusWatchInfo[] = [...this.watchdog.tabFocusWatchInfoHistory, this.watchdog.activeTabFocusInfo] as TabFocusWatchInfo[];\r\n\r\n        if (tabFocusHistoryWithCurrent.length < 2) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContentFromHTMLElement();\r\n        const currentContentTokens = simpleTokenizer(currentContent);\r\n        for (let i = 1; i < tabFocusHistoryWithCurrent.length; i++) {\r\n            const current = tabFocusHistoryWithCurrent[i];\r\n            const next = tabFocusHistoryWithCurrent[i + 1];\r\n\r\n            // find one or more paste events between current.focused_out and next.focused_out so we can assume that it was a tab switch followed by a paste, if the\r\n            // next has no focused_out, we use now as the end time\r\n            const endTime = next && next.focused_out ? next.focused_out : new Date();\r\n            const startTime = current.focused_out ? current.focused_out : current.focused_in;\r\n\r\n            const pastesInBetween = this.state.COPY_PASTE_CONTRIBUTIONS.filter(contribution => {\r\n                return contribution.timestamp >= startTime && contribution.timestamp <= endTime;\r\n            });\r\n            if (pastesInBetween.length > 0) {\r\n                totalPatterns++;\r\n                let maxScoreOfAPaste = 0;\r\n                pastesInBetween.forEach((contribution) => {\r\n                    let actualScore = 0;\r\n                    // we need to check against the current content\r\n                    // to see if the pasted content is included in the current content\r\n                    // in one way or another\r\n                    const tokenIncludesScoreValue = tokenIncludesScore(currentContentTokens, simpleTokenizer(contribution.content), 0.7);\r\n                    actualScore = tokenIncludesScoreValue * contribution.score;\r\n                    if (actualScore > maxScoreOfAPaste) {\r\n                        maxScoreOfAPaste = actualScore;\r\n                    }\r\n                });\r\n                switchingTabAndCopyPastingScore += maxScoreOfAPaste;\r\n            }\r\n        }\r\n\r\n        if (totalPatterns === 0) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const finalScore = switchingTabAndCopyPastingScore / totalPatterns;\r\n        this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = finalScore;\r\n    }\r\n    getCurrentAISignatureScore() {\r\n        // get the current value as text from the\r\n        return findAISignatures(this.getContentFromHTMLElement(), 1);\r\n    }\r\n    getContentFromHTMLElement() {\r\n        // get the value of the input field, textarea or contenteditable\r\n        if (this.element.tagName.toLowerCase() === 'textarea' || (this.element.tagName.toLowerCase() === 'input' && (this.element as HTMLInputElement).type === 'text')) {\r\n            return (this.element as HTMLInputElement).value;\r\n        } else if (this.element.isContentEditable) {\r\n            return this.element.innerText;\r\n        }\r\n        return '';\r\n    }\r\n    getLastAnalysis() {\r\n        // we need to reweight these factors based on the config weights\r\n        const WEIGHTED = {\r\n            COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE*this.watchdog.config.weights.reasons.COPY_RELATES_TO_PASTE,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES*this.watchdog.config.weights.reasons.CONTENT_CONTAINS_AI_SIGNATURES,\r\n            UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES*this.watchdog.config.weights.reasons.UNMODIFIED_PASTES,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING*this.watchdog.config.weights.reasons.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n\r\n        return {\r\n            raw: {\r\n                COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE,\r\n                CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES,\r\n                UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES,\r\n                KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n            },\r\n            weighted: WEIGHTED,\r\n            confidence: WEIGHTED.COPY_RELATES_TO_PASTE +\r\n                WEIGHTED.CONTENT_CONTAINS_AI_SIGNATURES +\r\n                WEIGHTED.UNMODIFIED_PASTES +\r\n                WEIGHTED.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n    }\r\n}\r\n\r\nexport interface TabFocusWatchInfo {\r\n    focused_in: Date;\r\n    focused_out?: Date;\r\n    duration_ms?: number;\r\n    gap_ms: number;\r\n    is_focused: boolean;\r\n}\r\n\r\nexport interface CopiedInfo {\r\n    timestamp: Date;\r\n    content: string;\r\n    tokens: string[];\r\n    size: number;\r\n}\r\n\r\n/**\r\n * Watchdog class to monitor copy-paste behavior and tab switching\r\n * this is the base class that manages the monitoring and analysis\r\n */\r\nclass Watchdog {\r\n    /**\r\n     * Configuration for the Watchdog module\r\n     */\r\n    config: WatchdogConfig;\r\n    /**\r\n     * Factors influencing the Watchdog's analysis\r\n     */\r\n    factors: WatchdogFactors;\r\n    /**\r\n     * Indicates whether the Watchdog is currently monitoring\r\n     */\r\n    isMonitoring: boolean = false;\r\n    /**\r\n     * Array of WatchdogHandle instances being monitored these\r\n     * represent the monitored input elements or textareas\r\n     */\r\n    handles: WatchdogHandle[] = [];\r\n    /**\r\n     * User ID being monitored\r\n     */\r\n    userId: string | null = null;\r\n    \r\n    /**\r\n     * Tab focus watch info history and active tab focus info\r\n     * keeping track of when the tab was focused and unfocused\r\n     * does not include the current active tab focus info\r\n     */\r\n    tabFocusWatchInfoHistory: TabFocusWatchInfo[] = [];\r\n    /**\r\n     * Active tab focus info representing the current tab focus state\r\n     */\r\n    activeTabFocusInfo: TabFocusWatchInfo | null = null;\r\n\r\n    /**\r\n     * Last copied info event\r\n     */\r\n    lastCopiedInfo: CopiedInfo | null = null;\r\n    /**\r\n     * History of last 10 copied info events, it includes the lastCopiedInfo as the last element\r\n     */\r\n    copyInfo10History: CopiedInfo[] = [];\r\n\r\n    /**\r\n     * Constructor for the Watchdog class\r\n     */\r\n    constructor() {\r\n        // Initialization code\r\n        this.config = DEFAULT_CONFIG;\r\n        this.factors = DEFAULT_FACTORS;\r\n        this.userId = null;\r\n\r\n        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\r\n        this.handleCopy = this.handleCopy.bind(this);\r\n    }\r\n\r\n    /**\r\n     * query an element to monitor, use a CSS selector to pick this element or provide the element directly\r\n     * @param selector \r\n     * @returns \r\n     */\r\n    query(selector: string | HTMLElement) {\r\n        // Implementation of query method\r\n        const element = typeof selector === \"string\" ? document.querySelectorAll(selector) : [selector];\r\n        // check that only one element is found\r\n        if (element.length !== 1) {\r\n            throw new Error(`Expected one element for selector \"${selector}\", but found ${element.length}.`);\r\n        }\r\n        const handle = new WatchdogHandle(element[0] as HTMLElement, this);\r\n        this.handles.push(handle);\r\n        return handle;\r\n    }\r\n    /**\r\n     * Query all elements matching the selector to monitor, use a CSS selector to pick these elements\r\n     * otherwise provide an array of elements directly\r\n     * @param selector \r\n     */\r\n    queryAll(selector: string | HTMLElement[]) {\r\n        // Implementation of queryAll method\r\n        const elements = typeof selector === \"string\" ? document.querySelectorAll(selector) : selector;\r\n        elements.forEach((el) => {\r\n            const handle = new WatchdogHandle(el as HTMLElement, this);\r\n            this.handles.push(handle);\r\n            return handle;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * initialize the Watchdog module, this needs to be called before starting monitoring\r\n     * otherwise an error will be thrown when trying to monitor elements, as the configuration\r\n     * and factors will not be set; you can re-initialize to change user or configuration on the fly\r\n     * \r\n     * @param userId \r\n     * @param config \r\n     * @param factors \r\n     */\r\n    initialize(\r\n        userId: string,\r\n        config?: Partial<WatchdogConfig>,\r\n        factors?: Partial<WatchdogFactors>,\r\n    ) {\r\n        // Implementation of initialize method\r\n        // patch DEFAULT_CONFIG and DEFAULT_FACTORS with provided config and factors\r\n        this.config = { ...DEFAULT_CONFIG, ...config };\r\n        this.factors = { ...DEFAULT_FACTORS, ...factors };\r\n        this.userId = userId;\r\n\r\n        if (!this.isMonitoring) {\r\n            this.beginMonitoring();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * stop the Watchdog monitoring\r\n     */\r\n    stop() {\r\n        // Implementation of stop method\r\n        this.isMonitoring = false;\r\n        this.handles.forEach((handle) => handle.stop());\r\n\r\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.removeEventListener('copy', this.handleCopy);\r\n    }\r\n\r\n    /**\r\n     * Change the user being monitored, stops and restarts monitoring for the new user\r\n     * \r\n     * @param userId \r\n     */\r\n    changeUser(userId: string) {\r\n        // Implementation of changeUser method\r\n        this.userId = userId;\r\n        this.stop();\r\n        this.handles.forEach((handle) => handle.loadState());\r\n        this.beginMonitoring();\r\n    }\r\n\r\n    /**\r\n     * Begin monitoring for copy-paste and tab switching events\r\n     */\r\n    beginMonitoring() {\r\n        // Implementation of beginMonitoring method\r\n        this.isMonitoring = true;\r\n\r\n        this.activeTabFocusInfo = {\r\n            focused_in: new Date(),\r\n            gap_ms: 0,\r\n            is_focused: true,\r\n        };\r\n        this.tabFocusWatchInfoHistory = []\r\n        this.lastCopiedInfo = null;\r\n        this.copyInfo10History = [];\r\n\r\n        document.addEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.addEventListener('copy', this.handleCopy);\r\n        \r\n        this.handles.forEach((handle) => {\r\n            if (handle.isInitialized) {\r\n                handle.restart();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle visibility change events to track tab focus and unfocus\r\n     */\r\n    handleVisibilityChange() {\r\n        if (document.hidden && this.activeTabFocusInfo) {\r\n            this.activeTabFocusInfo.focused_out = new Date();\r\n            this.activeTabFocusInfo.duration_ms = this.activeTabFocusInfo.focused_out.getTime() - this.activeTabFocusInfo.focused_in.getTime();\r\n            this.activeTabFocusInfo.is_focused = false;\r\n            this.tabFocusWatchInfoHistory.push(this.activeTabFocusInfo);\r\n            this.activeTabFocusInfo = null;\r\n        } else {\r\n            const lastFocusInfo = this.tabFocusWatchInfoHistory.length > 0 ? this.tabFocusWatchInfoHistory[this.tabFocusWatchInfoHistory.length - 1] : null;\r\n            const gap_ms = lastFocusInfo && lastFocusInfo.focused_out ? (new Date().getTime() - lastFocusInfo.focused_out.getTime()) : 0;\r\n            this.activeTabFocusInfo = {\r\n                focused_in: new Date(),\r\n                gap_ms: gap_ms,\r\n                is_focused: true,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle copy events to track copied content\r\n     */\r\n    handleCopy(event: ClipboardEvent) {\r\n        const clipboardData = event.clipboardData;\r\n        if (clipboardData) {\r\n            const content = clipboardData.getData('text/plain');\r\n            const size = content.length;\r\n            // check if it fits the copy size threshold\r\n            if (size < this.config.copy_size_threshold) {\r\n                return;\r\n            }\r\n            this.lastCopiedInfo = {\r\n                timestamp: new Date(),\r\n                content: content,\r\n                tokens: simpleTokenizer(content),\r\n                size: size,\r\n            };\r\n            this.copyInfo10History.push(this.lastCopiedInfo);\r\n            if (this.copyInfo10History.length > 10) {\r\n                this.copyInfo10History.shift();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// initialize the default watchdog instance\r\nconst watchdog = new Watchdog();\r\n\r\nexport default watchdog;\r\n", "import watchdog from './watchdog';\r\n\r\nconst scDetect: {\r\n    query: typeof watchdog.query;\r\n    initialize: typeof watchdog.initialize;\r\n    stop: typeof watchdog.stop;\r\n    queryAll: typeof watchdog.queryAll;\r\n    version: string;\r\n} = {\r\n    query: watchdog.query,\r\n    initialize: watchdog.initialize,\r\n    stop: watchdog.stop,\r\n    queryAll: watchdog.queryAll,\r\n    version: '1.0.0',\r\n}\r\n\r\nexport default scDetect;"],
  "mappings": "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",
  "names": ["SIMPLE_TOKENIZER_CACHE", "SIMPLE_TOKENIZER_CACHE_TIMEOUTS", "simpleTokenizer", "input", "tokens", "currentToken", "i", "char", "token", "normalizeToken", "accentsMap", "commonPrefixes", "commonSuffixes", "prefix", "suffix", "match", "tokenSimilarityCompare", "tokensA", "tokensB", "setA", "setB", "intersection", "x", "union", "tokenContainmentCompare", "tokensContainer", "tokensContained", "setContainer", "setContained", "tokenIncludesScore", "minimum_relevant", "score", "thisTokenMaxScoreSoFar", "j", "thisTokenScoreAtThisLocation", "matchLength", "matchMax", "k", "potentialScoreAdded", "finalScore", "findAISignatures", "text", "treshold", "score", "emDashCount", "emojiCount", "aiPhrases", "phrase", "phraseCount", "numerationCount", "DEFAULT_CONFIG", "DEFAULT_FACTORS", "WatchdogHandle", "element", "watchdog", "fn", "tagName", "type", "h", "e", "clipboardData", "text", "tokens", "simpleTokenizer", "similarity", "tokenSimilarityCompare", "containment", "tokenContainmentCompare", "now", "foundRelatedCopy", "foundRelatedCopyTimeFactor", "switchedTabsRecently", "switchedTabsRecentlyTimeFactor", "timeDiff", "foundRelatedCopyFactor", "switchedTabsRecentlyFactor", "cheatingPasteScore", "score", "aiScore", "findAISignatures", "total", "currentContent", "contribution", "tokenIncludesScoreValue", "tokenIncludesScore", "unmodifiedPastes", "totalPastes", "contentWorking", "unmodifiedPastesRatio", "remainingCharacters", "totalCharacters", "remainingCharactersRatio", "finalUnmodifiedPastesScore", "switchingTabAndCopyPastingScore", "totalPatterns", "tabFocusHistoryWithCurrent", "currentContentTokens", "i", "current", "next", "endTime", "startTime", "pastesInBetween", "maxScoreOfAPaste", "actualScore", "finalScore", "WEIGHTED", "Watchdog", "selector", "handle", "el", "userId", "config", "factors", "lastFocusInfo", "gap_ms", "event", "content", "size", "watchdog_default", "scDetect", "watchdog_default", "index_default"]
}
