{
  "version": 3,
  "sources": ["../js/tokenizer.ts", "../js/ai.ts", "../js/watchdog.ts", "../js/index.ts"],
  "sourcesContent": ["const SIMPLE_TOKENIZER_CACHE: { [key: string]: string[] } = {};\r\nconst SIMPLE_TOKENIZER_CACHE_TIMEOUTS : { [key: string]: any } = {};\r\n\r\nexport function simpleTokenizer(input: string): string[] {\r\n    if (SIMPLE_TOKENIZER_CACHE[input]) {\r\n        clearTimeout(SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input]);\r\n        SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n            delete SIMPLE_TOKENIZER_CACHE[input];\r\n            delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n        }, 60000); // Cache timeout of 60 seconds\r\n        return SIMPLE_TOKENIZER_CACHE[input];\r\n    }\r\n\r\n    const tokens: string[] = [];\r\n    let currentToken = '';\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n        const char = input[i];\r\n\r\n        if (/\\s/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n        } else if (/[.,!?;:()]/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n            tokens.push(char);\r\n        } else {\r\n            currentToken += char;\r\n        }\r\n    }\r\n\r\n    if (currentToken) {\r\n        tokens.push(currentToken);\r\n    }\r\n\r\n    SIMPLE_TOKENIZER_CACHE[input] = tokens.map((token) => normalizeToken(token)).filter((token) => token.length > 0);\r\n\r\n    SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n        delete SIMPLE_TOKENIZER_CACHE[input];\r\n        delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n    }, 60000); // Cache timeout of 60 seconds\r\n\r\n    return SIMPLE_TOKENIZER_CACHE[input];\r\n}\r\n\r\n// it should normalize tokens for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\nfunction normalizeToken(token: string): string {\r\n    const accentsMap: { [key: string]: string } = {\r\n        '\u00E1': 'a',\r\n        '\u00E9': 'e',\r\n        '\u00ED': 'i',\r\n        '\u00F3': 'o',\r\n        '\u00FA': 'u',\r\n        '\u00F1': 'n',\r\n        '\u00E4': 'a',\r\n        '\u00F6': 'o',\r\n        '\u00FC': 'u',\r\n    };\r\n\r\n    // normalize common prefixes and suffixes for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\n    const commonPrefixes = ['un', 're', 'in', 'im', 'dis', 'en', 'non', 'non-', 'pre', 'pre-', 'mis', 'sub', 'inter', 'fore', 'de', 'trans', 'super', 'semi', 'anti', 'mid', 'under'];\r\n    const commonSuffixes = ['s', 'es', 'ed', 'ing', 'ly', 'er', 'or', 'ion', 'tion', 'ation', 'ity', 'ment', 'ness', 'ful', 'less', 'est', 'ive', 'y', 'ize', 'ise', 'ify', 'en', 'ssa', 'lla', 'aa'];\r\n\r\n    for (const prefix of commonPrefixes) {\r\n        if (token.startsWith(prefix)) {\r\n            token = token.replace(prefix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    for (const suffix of commonSuffixes) {\r\n        if (token.endsWith(suffix)) {\r\n            token = token.replace(suffix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    return token\r\n        .toLowerCase()\r\n        .replace(/[\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1\u00E4\u00F6\u00FC]/g, (match) => accentsMap[match] || match);\r\n}\r\n\r\n/**\r\n * Checks how similar two token arrays are and gives a score between 0 and 1.\r\n * @param tokensA \r\n * @param tokensB \r\n * @returns \r\n */\r\nexport function tokenSimilarityCompare(tokensA: string[], tokensB: string[]): number {\r\n    const setA = new Set(tokensA);\r\n    const setB = new Set(tokensB);\r\n\r\n    const intersection = new Set([...setA].filter(x => setB.has(x)));\r\n    const union = new Set([...setA, ...setB]);\r\n\r\n    return intersection.size / union.size;\r\n}\r\n\r\n/**\r\n * Checks what proportion of tokens in tokensContained are also in tokensContainer and gives a score between 0 and 1.\r\n * @param tokensContainer \r\n * @param tokensContained \r\n */\r\nexport function tokenContainmentCompare(tokensContainer: string[], tokensContained: string[]): number {\r\n    const setContainer = new Set(tokensContainer);\r\n    const setContained = new Set(tokensContained);\r\n\r\n    const intersection = new Set([...setContained].filter(x => setContainer.has(x)));\r\n\r\n    return intersection.size / setContained.size;\r\n}\r\n\r\nexport function tokenIncludesScore(tokensContainer: string[], tokensContained: string[], minimum_relevant: number): number {\r\n    // we need to look for exact sequences of tokensContained in tokensContainer in the same order as well as potential fragments\r\n    let score = 0;\r\n    // we will iterate over tokensContained to check each token as if it is found\r\n    for (let i = 0; i < tokensContained.length; i++) {\r\n        // find the token in tokensContainer\r\n        let thisTokenMaxScoreSoFar = 0;\r\n        // now we will iterate over tokensContainer to find matches\r\n        for (let j = 0; j < tokensContainer.length; j++) {\r\n            // check if tokensContainer[j] matches tokensContained[i]\r\n            if (tokensContainer[j] === tokensContained[i]) {\r\n                // now we need to see how many tokens match in sequence from this point\r\n                // we will calculate a score for this token match based on how many tokens match in sequence\r\n                let thisTokenScoreAtThisLocation = 0;\r\n                // we found a match, now let's check if the token is surrounded by the tokens before and after it that match as well\r\n                let matchLength = 0;\r\n                let matchMax = 0\r\n                // check backwards and forwards, seeing how well the surrounding tokens match\r\n                for (let k = -i; k < tokensContained.length - i; k++) {\r\n                    // the further away we go, the less weight it has, so we add a fraction of 1 based on how far we are from the center\r\n                    const potentialScoreAdded = 1 - (Math.abs(k) / tokensContained.length);\r\n                    matchMax += potentialScoreAdded;\r\n                    if (tokensContainer[j + k] === tokensContained[i + k]) {\r\n                        matchLength += potentialScoreAdded\r\n                    }\r\n                }\r\n\r\n                // calculate score for this token at this location\r\n                thisTokenScoreAtThisLocation = matchLength / matchMax;\r\n                \r\n                // see if it's the best score for this token so far\r\n                // use a max function to keep the best score\r\n                if (thisTokenScoreAtThisLocation > thisTokenMaxScoreSoFar) {\r\n                    thisTokenMaxScoreSoFar = thisTokenScoreAtThisLocation;\r\n                }\r\n            }\r\n        }\r\n\r\n        // add the best score for this token to the total score\r\n        score += thisTokenMaxScoreSoFar;\r\n    }\r\n\r\n    // average the score over the number of tokens contained\r\n    const finalScore = score / tokensContained.length;\r\n\r\n    // check if the final score is above the minimum relevant threshold\r\n    if (finalScore >= minimum_relevant) {\r\n        return finalScore;\r\n    }\r\n\r\n    return 0;\r\n}", "export function findAISignatures(text: string, treshold: number = 1): number {\r\n    // find ai signatures in the text that suggest it was generated by an ai language model\r\n    // for example em dashes\r\n    // emojis in the text\r\n    // certain phrases like \"as an ai language model\"\r\n    // numeration styles like \"1.\", \"2.\", \"3.\"\r\n    let score = 0;\r\n    const emDashCount = (text.match(/\u2014/g) || []).length;\r\n    score += emDashCount * 0.3;\r\n\r\n    const doubleMultiplierCount = (text.match(/\\*\\*/g) || []).length;\r\n    score += doubleMultiplierCount * 0.15;\r\n\r\n    // find emojis\r\n    const emojiCount = (text.match(/(?:\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F)(?:\\u200D(?:\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F))*|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}/gu) || []).length;\r\n    score += emojiCount * 0.5;\r\n\r\n    // find phrases\r\n    const aiPhrases = [\r\n        'as an ai language model',\r\n        'i am an ai',\r\n        'i am an artificial intelligence',\r\n        'as an artificial intelligence',\r\n        'chatgpt',\r\n        'gemini',\r\n        'claude'\r\n    ];\r\n    for (const phrase of aiPhrases) {\r\n        const phraseCount = (text.toLowerCase().match(new RegExp(phrase, 'g')) || []).length;\r\n        score += phraseCount * 1;\r\n    }\r\n\r\n    // find numeration styles\r\n    const numerationCount = (text.match(/\\b\\d+\\./g) || []).length;\r\n    score += numerationCount * 0.05;\r\n\r\n    if (score > treshold) {\r\n        return 1\r\n    }\r\n    return 0;\r\n}", "import { simpleTokenizer, tokenContainmentCompare, tokenIncludesScore, tokenSimilarityCompare } from \"./tokenizer\";\r\nimport { findAISignatures } from \"./ai\";\r\n\r\n/**\r\n * Watchdog module to monitor copy-paste behavior and tab switching\r\n * to detect potential cheating\r\n * \r\n * weights:\r\n *  - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: weight for the factor that measures\r\n *    how much the user keeps switching tabs and copy-pasting\r\n *  - COPY_RELATES_TO_PASTE: weight for the factor that measures how much\r\n *   the copy events relate to the paste events\r\n *  - CONTENT_CONTAINS_AI_SIGNATURES: weight for the factor that measures\r\n *   how much the content contains AI signatures\r\n *  - UNMODIFIED_PASTES: weight for the factor that measures how much\r\n *  the pastes are unmodified\r\n * \r\n * min_copy_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * min_tab_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * \r\n * Keep the weights summing to 1.0 in order to have a proper confidence score\r\n * between 0 and 1.0\r\n * \r\n * Note that a confidence score close to 1.0 does not necessarily mean cheating,\r\n * but rather a high likelihood of cheating behavior based on the monitored factors.\r\n * A human review is still recommended for high confidence scores.\r\n * \r\n * paste_size_threshold: minimum size of pasted content to consider\r\n * copy_size_threshold: minimum size of copied content to consider\r\n * settings:\r\n *  - relevant_copy_event_minutes: time window in minutes to consider\r\n *    copy events as relevant to paste events\r\n *  - relevant_tab_in_out_event_minutes: time window in minutes to consider\r\n *    tab in/out events as relevant to copy-paste behavior\r\n */\r\nexport interface WatchdogConfig {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number,\r\n            COPY_RELATES_TO_PASTE: number,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: number,\r\n            UNMODIFIED_PASTES: number,\r\n        },\r\n        min_copy_event_time_weight: number,\r\n        min_tab_event_time_weight: number,\r\n    },\r\n    paste_size_threshold: number,\r\n    copy_size_threshold: number,\r\n    settings: {\r\n        relevant_copy_event_minutes: number;\r\n        relevant_tab_in_out_event_minutes: number;\r\n    }\r\n}\r\n\r\n/**\r\n * The default configuration for the Watchdog module\r\n */\r\nconst DEFAULT_CONFIG: WatchdogConfig = {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0.3,\r\n            COPY_RELATES_TO_PASTE: 0.3,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0.2,\r\n            UNMODIFIED_PASTES: 0.1,\r\n        },\r\n        min_copy_event_time_weight: 0.5,\r\n        min_tab_event_time_weight: 0.5,\r\n    },\r\n    paste_size_threshold: 30,\r\n    copy_size_threshold: 30,\r\n    settings: {\r\n        relevant_copy_event_minutes: 5,\r\n        relevant_tab_in_out_event_minutes: 5,\r\n    }\r\n}\r\n\r\n/**\r\n * Factors that influence the Watchdog analysis\r\n * - deadline: time remaining until the deadline in minutes, if zero or negative, no deadline\r\n * - caught_rate: rate of previous cheating detections for the user, between 0 and 1\r\n * - non_native_language: whether the user is using a non-native language for the test\r\n */\r\nexport interface WatchdogFactors {\r\n    deadline: number,\r\n    caught_rate: number,\r\n    non_native_language: boolean,\r\n}\r\n\r\n/**\r\n * The default factors for the Watchdog module\r\n * - deadline: 0 (no deadline)\r\n * - caught_rate: 0 (no previous cheating detections)\r\n * - non_native_language: false (native language)\r\n */\r\nconst DEFAULT_FACTORS: WatchdogFactors = {\r\n    deadline: 0,\r\n    caught_rate: 0,\r\n    non_native_language: false,\r\n}\r\n\r\n/**\r\n * Interface for copy-paste contribution objects\r\n */\r\nexport interface CopyPasteContribution {\r\n    /**\r\n     * AI signature score for the pasted content, a number between 0 and 1 on whether the content has AI signatures\r\n     */\r\n    aiScore: number;\r\n    /**\r\n     * Cheating paste score based on similarity and related copy/tab switch events, a number between 0 and 1\r\n     */\r\n    pasteScore: number;\r\n    /**\r\n     * Final score for this contribution, a number between 0 and 1, the maximum between aiScore and pasteScore\r\n     */\r\n    score: number;\r\n    /**\r\n     * Timestamp of the paste event\r\n     */\r\n    timestamp: Date;\r\n    /**\r\n     * Similarity between copied and pasted content, a number between 0 and 1\r\n     */\r\n    similarity: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the content of the tokens, a number between 0 and 1\r\n     */\r\n    containment: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the time and tab switching, a number between 0 and 1\r\n     */\r\n    copyFactor: number;\r\n    /**\r\n     * Factor how much a paste is related to a tab switch event, based on the time, a number between 0 and 1\r\n     */\r\n    tabSwitchFactor: number;\r\n    /**\r\n     * Content of the pasted text\r\n     */\r\n    content: string;\r\n}\r\n\r\n/**\r\n * State interface for each WatchdogHandle, each one represents a monitored input element or textarea\r\n * - COPY_PASTE_CONTRIBUTIONS: array of copy-paste contribution objects\r\n * - COPY_RELATES_TO_PASTE: score for the factor that measures how much copy events relate to paste events\r\n * - CONTENT_CONTAINS_AI_SIGNATURES: score for the factor that measures how much the content contains AI signatures\r\n * - UNMODIFIED_PASTES: score for the factor that measures how much the pastes are unmodified\r\n * - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: score for the factor that measures how much the user keeps switching tabs and copy-pasting\r\n * \r\n * All factors are between 0 and 1, the final confidence score is calculated\r\n * by weighting each factor according to the weights defined in the WatchdogConfig\r\n */\r\nexport interface WatchdogHandleState {\r\n    COPY_PASTE_CONTRIBUTIONS: Array<CopyPasteContribution>;\r\n    COPY_RELATES_TO_PASTE: number;\r\n    CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n    UNMODIFIED_PASTES: number;\r\n    KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n}\r\n\r\nexport type WatchdogStateLoader = () => Promise<WatchdogHandleState>;\r\n\r\nclass WatchdogHandle {\r\n    element: HTMLElement;\r\n    watchdog: Watchdog;\r\n    isInitialized: boolean = false;\r\n    state: WatchdogHandleState;\r\n    loadStateLoader: WatchdogStateLoader | null = null;\r\n    listeners: Array<(analysis: IWatchdogAnalysis) => void> = [];\r\n    //shouldBeAttemptedToProcessAsInputDiff: boolean = false;\r\n    //lastInputValue: string = \"\";\r\n    //selectionWhilePaste: string = \"\";\r\n\r\n    constructor(element: HTMLElement, watchdog: Watchdog) {\r\n        this.element = element;\r\n        this.watchdog = watchdog;\r\n        this.state = {\r\n            COPY_PASTE_CONTRIBUTIONS: [],\r\n            // INPUT_CONTRIBUTIONS: [],\r\n\r\n            COPY_RELATES_TO_PASTE: 0,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0,\r\n            UNMODIFIED_PASTES: 0,\r\n        };\r\n\r\n        this.handlePaste = this.handlePaste.bind(this);\r\n        this.handleInput = this.handleInput.bind(this);\r\n    }\r\n    setStateLoader(fn: WatchdogStateLoader) {\r\n        this.loadStateLoader = fn;\r\n    }\r\n    async initialize() {\r\n        if (!this.watchdog.isMonitoring) {\r\n            throw new Error('Watchdog is not initialized. Please call scDetect.initialize() first.');\r\n        }\r\n        this.isInitialized = true;\r\n        // make sure that is in an input with contenteditable or textarea or input type=text\r\n        const tagName = this.element.tagName.toLowerCase();\r\n        const type = (this.element as HTMLInputElement).type;\r\n        if (tagName === 'textarea' || (tagName === 'input' && type === 'text') || this.element.isContentEditable) {\r\n            // Start monitoring the element for copy-paste and tab switch events\r\n            // Implementation of monitoring logic goes here\r\n            await this.loadState();\r\n            this.restart();\r\n        } else {\r\n            throw new Error('Element is not a valid input field (textarea, input type=text, or contenteditable).');\r\n        }\r\n    }\r\n    async loadState() {\r\n        // Implementation of loadState method for this handle\r\n        // Load any saved state from this.state\r\n        if (this.loadStateLoader) {\r\n            this.state = await this.loadStateLoader();\r\n        }\r\n\r\n        // TODO other loading mechanisms can be added here\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n        this.onNewScoreCalculated();\r\n    }\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    restart() {\r\n        if (!this.isInitialized) {\r\n            throw new Error('WatchdogHandle is not initialized. Please call initialize() first.');\r\n        }\r\n        \r\n        //this.lastInputValue = this.getContentFromHTMLElement();\r\n\r\n        // Implementation of restart method for this handle\r\n        // add event listeners to paste, input\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput as any);\r\n        this.element.addEventListener('paste', this.handlePaste);\r\n        this.element.addEventListener('input', this.handleInput as any);\r\n    }\r\n    stop() {\r\n        // Implementation of stop method for this handle\r\n        this.isInitialized = false;\r\n\r\n        // remove all event listeners\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput as any);\r\n    }\r\n    destroy() {\r\n        // Implementation of destroy method for this handle\r\n        this.stop();\r\n        // Additional cleanup\r\n        this.watchdog.handles = this.watchdog.handles.filter(h => h !== this);\r\n    }\r\n    handleInput(e: InputEvent) {\r\n        //if (e.inputType === \"insertFromPaste\" && this.shouldBeAttemptedToProcessAsInputDiff) {\r\n        //    this.shouldBeAttemptedToProcessAsInputDiff = false;\r\n\r\n        //    const originalText = this.lastInputValue.replace(this.selectionWhilePaste, '');\r\n        //    const currentText = this.getContentFromHTMLElement();\r\n\r\n        //    let newText = \"\"\r\n        //    let startIndex = 0;\r\n        //    let endIndex = currentText.length - 1;\r\n\r\n            // we want to move this cursor through the originalText and currentText and find where they differ to set our start index\r\n        //    while (startIndex < originalText.length && startIndex < currentText.length && originalText[startIndex] === currentText[startIndex]) {\r\n        //        startIndex++;\r\n        //    }\r\n            // now we do the same from the end to find the end index\r\n        //    while (endIndex >= 0 && endIndex >= startIndex && originalText[originalText.length - 1 - (currentText.length - 1 - endIndex)] === currentText[endIndex]) {\r\n        //        endIndex--;\r\n        //    }\r\n\r\n        //    if (endIndex >= startIndex) {\r\n        //        newText = currentText.substring(startIndex, endIndex + 1);\r\n        //        console.log(newText);\r\n        //        this.handlePastedText(newText);\r\n        //    }\r\n\r\n        //}\r\n\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n        this.onNewScoreCalculated();\r\n\r\n        //this.lastInputValue = this.getContentFromHTMLElement();\r\n    }\r\n    /**\r\n     * If you want to refresh the internal input value\r\n     * Because you have some external code modifying the input value\r\n     * programmatically rather than the user typing or pasting, please\r\n     * call this method to update the internal state.\r\n     */\r\n    //refreshInternalInputValue() {\r\n    //    this.lastInputValue = this.getContentFromHTMLElement();\r\n    //}\r\n    handlePaste(e: ClipboardEvent) {\r\n        const clipboardData = e.clipboardData;\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n        const text = clipboardData.getData('text/plain');\r\n\r\n        if (!text) {\r\n            //this.shouldBeAttemptedToProcessAsInputDiff = true;\r\n            //this.selectionWhilePaste = document.getSelection()?.toString() || \"\";\r\n            return;\r\n        }\r\n\r\n        // check if it fits the paste size threshold\r\n        if (text.length < this.watchdog.config.paste_size_threshold) {\r\n            return;\r\n        }\r\n\r\n        this.handlePastedText(text);\r\n    }\r\n\r\n    handlePastedText(text: string) {\r\n        const tokens = simpleTokenizer(text);\r\n        const similarity = tokenSimilarityCompare(tokens, this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : []);\r\n        const containment = this.watchdog.lastCopiedInfo?.tokens.length ? tokenContainmentCompare(tokens, this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : []) : 0;\r\n\r\n        // similarities too high are likely modified pastes, so we just ignore them\r\n        if (similarity > 0.9) {\r\n            return;\r\n        }\r\n\r\n        // Now lets look for a copy event, followed by a tabout event, followed by this paste event\r\n        // within a reasonable time frame (e.g., 5 minutes)\r\n        const now = new Date();\r\n        let foundRelatedCopy = false;\r\n        let foundRelatedCopyTimeFactor = 0;\r\n        let switchedTabsRecently = false;\r\n        let switchedTabsRecentlyTimeFactor = 0;\r\n\r\n        if (this.watchdog.lastCopiedInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.lastCopiedInfo.timestamp.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000) {\r\n                foundRelatedCopy = true;\r\n                foundRelatedCopyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000));\r\n                if (foundRelatedCopyTimeFactor < this.watchdog.config.weights.min_copy_event_time_weight) {\r\n                    foundRelatedCopyTimeFactor = this.watchdog.config.weights.min_copy_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.watchdog.activeTabFocusInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.activeTabFocusInfo.focused_in.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000) {\r\n                switchedTabsRecently = true;\r\n                switchedTabsRecentlyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000));\r\n                if (switchedTabsRecentlyTimeFactor < this.watchdog.config.weights.min_tab_event_time_weight) {\r\n                    switchedTabsRecentlyTimeFactor = this.watchdog.config.weights.min_tab_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        const foundRelatedCopyFactor = (foundRelatedCopy ? 1 : 0) * foundRelatedCopyTimeFactor;\r\n        const switchedTabsRecentlyFactor = (switchedTabsRecently ? 1 : 0) * switchedTabsRecentlyTimeFactor;\r\n        // the cheating paste score is the average of the three factors\r\n        // we weight equally the containment, as in if the pasted content relates to copied content and by how much it relates\r\n        // and the foundRelatedCopyFactor and switchedTabsRecentlyFactor, which are time-weighted factors indicating recent related copy and tab switch events\r\n        const cheatingPasteScore = containment * foundRelatedCopyFactor * switchedTabsRecentlyFactor;\r\n        let score = cheatingPasteScore;\r\n\r\n        // we also check for AI signatures in the pasted content\r\n        const aiScore = findAISignatures(text, 1);\r\n\r\n        // if aiScore is higher than cheatingPasteScore, we use that as the score\r\n        if (aiScore >= cheatingPasteScore) {\r\n            score *= aiScore;\r\n        }\r\n\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.push({\r\n            pasteScore: cheatingPasteScore,\r\n            score: score,\r\n            aiScore: aiScore,\r\n            timestamp: now,\r\n            similarity: similarity,\r\n            containment: containment,\r\n            copyFactor: foundRelatedCopyFactor,\r\n            tabSwitchFactor: switchedTabsRecentlyFactor,\r\n            content: text,\r\n        });\r\n    }\r\n    private recalculateCopyRelatesToPaste() {\r\n        // calculate average score, guarding against empty contributions array\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.COPY_RELATES_TO_PASTE = 0;\r\n        } else {\r\n            // we average the scores of all contributions\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.score;\r\n            })\r\n            this.state.COPY_RELATES_TO_PASTE = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateAIScore() {\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = 0;\r\n        } else {\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.aiScore;\r\n            })\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateUnmodifiedPastes() {\r\n        // recalculate unmodified pastes factor\r\n        let unmodifiedPastes = 0;\r\n        const totalPastes = this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n\r\n        if (totalPastes === 0) {\r\n            this.state.UNMODIFIED_PASTES = 0;\r\n            return;\r\n        }\r\n\r\n        let contentWorking = this.getContentFromHTMLElement();\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n            if (contentWorking.includes(contribution.content)) {\r\n                unmodifiedPastes++;\r\n                // remove the pasted content from the working content to avoid double counting\r\n                contentWorking = contentWorking.replace(contribution.content, '');\r\n            } else {\r\n                // find a match sentence by sentence\r\n                const sentences = contribution.content.split(/(?<=[.!?])\\s+|\\n|\\r\\n/).filter(s => s.trim().length > 0);\r\n                let localUnmodifiedPastes = 0;\r\n                for (const sentence of sentences) {\r\n                    if (contentWorking.includes(sentence)) {\r\n                        localUnmodifiedPastes++;\r\n                        // remove the pasted content from the working content to avoid double counting\r\n                        contentWorking = contentWorking.replace(sentence, '');\r\n                    }\r\n                }\r\n                unmodifiedPastes += localUnmodifiedPastes / sentences.length;\r\n            }\r\n        });\r\n\r\n        const unmodifiedPastesRatio = unmodifiedPastes / totalPastes;\r\n        const remainingCharacters = contentWorking.length;\r\n        const totalCharacters = this.getContentFromHTMLElement().length;\r\n        const remainingCharactersRatio = totalCharacters > 0 ? remainingCharacters / totalCharacters : 0;\r\n\r\n        // combine both ratios to get a final unmodified pastes score\r\n        const finalUnmodifiedPastesScore = (unmodifiedPastesRatio + (1 - remainingCharactersRatio)) / 2;\r\n\r\n        this.state.UNMODIFIED_PASTES = finalUnmodifiedPastesScore;  \r\n    }\r\n    private recalculateKeepsSwitchingTabsAndCopyPasting() {\r\n        // recalculate keeps switching tabs and copy pasting factor\r\n        // for that we will look for an ever alternating pattern of tab switches followed by a paste event\r\n        let switchingTabAndCopyPastingScore = 0;\r\n        let totalPatterns = 0;\r\n\r\n        // first let's loop in the tab focus history to find tab switches\r\n        const tabFocusHistoryWithCurrent: TabFocusWatchInfo[] = [...this.watchdog.tabFocusWatchInfoHistory, this.watchdog.activeTabFocusInfo] as TabFocusWatchInfo[];\r\n\r\n        if (tabFocusHistoryWithCurrent.length < 2) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContentFromHTMLElement();\r\n        const currentContentTokens = simpleTokenizer(currentContent);\r\n        for (let i = 1; i < tabFocusHistoryWithCurrent.length; i++) {\r\n            const current = tabFocusHistoryWithCurrent[i];\r\n            const next = tabFocusHistoryWithCurrent[i + 1];\r\n\r\n            // find one or more paste events between current.focused_out and next.focused_out so we can assume that it was a tab switch followed by a paste, if the\r\n            // next has no focused_out, we use now as the end time\r\n            const endTime = next && next.focused_out ? next.focused_out : new Date();\r\n            const startTime = current.focused_out ? current.focused_out : current.focused_in;\r\n\r\n            const pastesInBetween = this.state.COPY_PASTE_CONTRIBUTIONS.filter(contribution => {\r\n                return contribution.timestamp >= startTime && contribution.timestamp <= endTime;\r\n            });\r\n            if (pastesInBetween.length > 0) {\r\n                totalPatterns++;\r\n                let maxScoreOfAPaste = 0;\r\n                pastesInBetween.forEach((contribution) => {\r\n                    let actualScore = 0;\r\n                    // we need to check against the current content\r\n                    // to see if the pasted content is included in the current content\r\n                    // in one way or another\r\n                    const tokenIncludesScoreValue = tokenIncludesScore(currentContentTokens, simpleTokenizer(contribution.content), 0.7);\r\n                    actualScore = tokenIncludesScoreValue * contribution.score;\r\n                    if (actualScore > maxScoreOfAPaste) {\r\n                        maxScoreOfAPaste = actualScore;\r\n                    }\r\n                });\r\n                switchingTabAndCopyPastingScore += maxScoreOfAPaste;\r\n            }\r\n        }\r\n\r\n        if (totalPatterns === 0) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const finalScore = switchingTabAndCopyPastingScore / totalPatterns;\r\n        this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = finalScore;\r\n    }\r\n    getCurrentAISignatureScore() {\r\n        // get the current value as text from the\r\n        return findAISignatures(this.getContentFromHTMLElement(), 1);\r\n    }\r\n    getContentFromHTMLElement() {\r\n        // get the value of the input field, textarea or contenteditable\r\n        if (this.element.tagName.toLowerCase() === 'textarea' || (this.element.tagName.toLowerCase() === 'input' && (this.element as HTMLInputElement).type === 'text')) {\r\n            return (this.element as HTMLInputElement).value;\r\n        } else if (this.element.isContentEditable) {\r\n            return this.element.innerText;\r\n        }\r\n        return '';\r\n    }\r\n    getLastAnalysis(): IWatchdogAnalysis {\r\n        // we need to reweight these factors based on the config weights\r\n        const WEIGHTED = {\r\n            COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE*this.watchdog.config.weights.reasons.COPY_RELATES_TO_PASTE,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES*this.watchdog.config.weights.reasons.CONTENT_CONTAINS_AI_SIGNATURES,\r\n            UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES*this.watchdog.config.weights.reasons.UNMODIFIED_PASTES,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING*this.watchdog.config.weights.reasons.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n\r\n        return {\r\n            raw: {\r\n                COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE,\r\n                CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES,\r\n                UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES,\r\n                KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n            },\r\n            weighted: WEIGHTED,\r\n            confidence: WEIGHTED.COPY_RELATES_TO_PASTE +\r\n                WEIGHTED.CONTENT_CONTAINS_AI_SIGNATURES +\r\n                WEIGHTED.UNMODIFIED_PASTES +\r\n                WEIGHTED.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n    }\r\n    private onNewScoreCalculated() {\r\n        // placeholder for future event handling when a new score is calculated\r\n        const analysis = this.getLastAnalysis();\r\n        this.listeners.forEach((listener) => {\r\n            listener(analysis);\r\n        });\r\n    }\r\n    public addEventListenerOnNewScoreCalculated(callback: (analysis: IWatchdogAnalysis) => void) {\r\n        this.listeners.push(callback);\r\n    }\r\n    public removeEventListenerOnNewScoreCalculated(callback: (analysis: IWatchdogAnalysis) => void) {\r\n        this.listeners = this.listeners.filter(listener => listener !== callback);\r\n    }\r\n}\r\n\r\nexport interface IWatchdogAnalysis {\r\n    raw: {\r\n        COPY_RELATES_TO_PASTE: number;\r\n        CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n        UNMODIFIED_PASTES: number;\r\n        KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n    };\r\n    weighted: {\r\n        COPY_RELATES_TO_PASTE: number;\r\n        CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n        UNMODIFIED_PASTES: number;\r\n        KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n    };\r\n    confidence: number;\r\n}\r\n\r\nexport interface TabFocusWatchInfo {\r\n    focused_in: Date;\r\n    focused_out?: Date;\r\n    duration_ms?: number;\r\n    gap_ms: number;\r\n    is_focused: boolean;\r\n}\r\n\r\nexport interface CopiedInfo {\r\n    timestamp: Date;\r\n    content: string;\r\n    tokens: string[];\r\n    size: number;\r\n}\r\n\r\n/**\r\n * Watchdog class to monitor copy-paste behavior and tab switching\r\n * this is the base class that manages the monitoring and analysis\r\n */\r\nclass Watchdog {\r\n    /**\r\n     * Configuration for the Watchdog module\r\n     */\r\n    config: WatchdogConfig;\r\n    /**\r\n     * Factors influencing the Watchdog's analysis\r\n     */\r\n    factors: WatchdogFactors;\r\n    /**\r\n     * Indicates whether the Watchdog is currently monitoring\r\n     */\r\n    isMonitoring: boolean = false;\r\n    /**\r\n     * Array of WatchdogHandle instances being monitored these\r\n     * represent the monitored input elements or textareas\r\n     */\r\n    handles: WatchdogHandle[] = [];\r\n    /**\r\n     * User ID being monitored\r\n     */\r\n    userId: string | null = null;\r\n    \r\n    /**\r\n     * Tab focus watch info history and active tab focus info\r\n     * keeping track of when the tab was focused and unfocused\r\n     * does not include the current active tab focus info\r\n     */\r\n    tabFocusWatchInfoHistory: TabFocusWatchInfo[] = [];\r\n    /**\r\n     * Active tab focus info representing the current tab focus state\r\n     */\r\n    activeTabFocusInfo: TabFocusWatchInfo | null = null;\r\n\r\n    /**\r\n     * Last copied info event\r\n     */\r\n    lastCopiedInfo: CopiedInfo | null = null;\r\n    /**\r\n     * History of last 10 copied info events, it includes the lastCopiedInfo as the last element\r\n     */\r\n    copyInfo10History: CopiedInfo[] = [];\r\n\r\n    /**\r\n     * Constructor for the Watchdog class\r\n     */\r\n    constructor() {\r\n        // Initialization code\r\n        this.config = DEFAULT_CONFIG;\r\n        this.factors = DEFAULT_FACTORS;\r\n        this.userId = null;\r\n\r\n        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\r\n        this.handleCopy = this.handleCopy.bind(this);\r\n        this.query = this.query.bind(this);\r\n        this.queryAll = this.queryAll.bind(this);\r\n        this.initialize = this.initialize.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.changeUser = this.changeUser.bind(this);\r\n        this.beginMonitoring = this.beginMonitoring.bind(this);\r\n    }\r\n\r\n    /**\r\n     * query an element to monitor, use a CSS selector to pick this element or provide the element directly\r\n     * @param selector \r\n     * @returns \r\n     */\r\n    query(selector: string | HTMLElement) {\r\n        // Implementation of query method\r\n        const element = typeof selector === \"string\" ? document.querySelectorAll(selector) : [selector];\r\n        // check that only one element is found\r\n        if (element.length !== 1) {\r\n            throw new Error(`Expected one element for selector \"${selector}\", but found ${element.length}.`);\r\n        }\r\n        const handle = new WatchdogHandle(element[0] as HTMLElement, this);\r\n        this.handles.push(handle);\r\n        return handle;\r\n    }\r\n    /**\r\n     * Query all elements matching the selector to monitor, use a CSS selector to pick these elements\r\n     * otherwise provide an array of elements directly\r\n     * @param selector \r\n     */\r\n    queryAll(selector: string | HTMLElement[]) {\r\n        // Implementation of queryAll method\r\n        const elements = typeof selector === \"string\" ? document.querySelectorAll(selector) : selector;\r\n        return Array.from(elements).map((el) => {\r\n            const handle = new WatchdogHandle(el as HTMLElement, this);\r\n            this.handles.push(handle);\r\n            return handle;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * initialize the Watchdog module, this needs to be called before starting monitoring\r\n     * otherwise an error will be thrown when trying to monitor elements, as the configuration\r\n     * and factors will not be set; you can re-initialize to change user or configuration on the fly\r\n     * \r\n     * @param userId \r\n     * @param config \r\n     * @param factors \r\n     */\r\n    initialize(\r\n        userId: string,\r\n        config?: Partial<WatchdogConfig>,\r\n        factors?: Partial<WatchdogFactors>,\r\n    ) {\r\n        // Implementation of initialize method\r\n        // patch DEFAULT_CONFIG and DEFAULT_FACTORS with provided config and factors\r\n        this.config = { ...DEFAULT_CONFIG, ...config };\r\n        this.factors = { ...DEFAULT_FACTORS, ...factors };\r\n        this.userId = userId;\r\n\r\n        if (!this.isMonitoring) {\r\n            this.beginMonitoring();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * stop the Watchdog monitoring\r\n     */\r\n    stop() {\r\n        // Implementation of stop method\r\n        this.isMonitoring = false;\r\n        this.handles.forEach((handle) => handle.stop());\r\n\r\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.removeEventListener('copy', this.handleCopy);\r\n    }\r\n\r\n    /**\r\n     * Change the user being monitored, stops and restarts monitoring for the new user\r\n     * \r\n     * @param userId \r\n     */\r\n    changeUser(userId: string) {\r\n        // Implementation of changeUser method\r\n        this.userId = userId;\r\n        this.stop();\r\n        this.handles.forEach((handle) => handle.loadState());\r\n        this.beginMonitoring();\r\n    }\r\n\r\n    /**\r\n     * Begin monitoring for copy-paste and tab switching events\r\n     */\r\n    beginMonitoring() {\r\n        // Implementation of beginMonitoring method\r\n        this.isMonitoring = true;\r\n\r\n        this.activeTabFocusInfo = {\r\n            focused_in: new Date(),\r\n            gap_ms: 0,\r\n            is_focused: true,\r\n        };\r\n        this.tabFocusWatchInfoHistory = []\r\n        this.lastCopiedInfo = null;\r\n        this.copyInfo10History = [];\r\n\r\n        document.addEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.addEventListener('copy', this.handleCopy);\r\n        \r\n        this.handles.forEach((handle) => {\r\n            if (handle.isInitialized) {\r\n                handle.restart();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle visibility change events to track tab focus and unfocus\r\n     */\r\n    handleVisibilityChange() {\r\n        if (document.hidden && this.activeTabFocusInfo) {\r\n            this.activeTabFocusInfo.focused_out = new Date();\r\n            this.activeTabFocusInfo.duration_ms = this.activeTabFocusInfo.focused_out.getTime() - this.activeTabFocusInfo.focused_in.getTime();\r\n            this.activeTabFocusInfo.is_focused = false;\r\n            this.tabFocusWatchInfoHistory.push(this.activeTabFocusInfo);\r\n            this.activeTabFocusInfo = null;\r\n        } else {\r\n            const lastFocusInfo = this.tabFocusWatchInfoHistory.length > 0 ? this.tabFocusWatchInfoHistory[this.tabFocusWatchInfoHistory.length - 1] : null;\r\n            const gap_ms = lastFocusInfo && lastFocusInfo.focused_out ? (new Date().getTime() - lastFocusInfo.focused_out.getTime()) : 0;\r\n            this.activeTabFocusInfo = {\r\n                focused_in: new Date(),\r\n                gap_ms: gap_ms,\r\n                is_focused: true,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle copy events to track copied content\r\n     */\r\n    handleCopy(event: ClipboardEvent) {\r\n        const clipboardData = event.clipboardData;\r\n        if (clipboardData) {\r\n            const content = clipboardData.getData('text/plain');\r\n            const selectedText = window.getSelection()?.toString() || '';\r\n            const finalContent = content || selectedText;\r\n            if (!finalContent) {\r\n                return;\r\n            }\r\n            const size = finalContent.length;\r\n            // check if it fits the copy size threshold\r\n            if (size < this.config.copy_size_threshold) {\r\n                return;\r\n            }\r\n            this.lastCopiedInfo = {\r\n                timestamp: new Date(),\r\n                content: finalContent,\r\n                tokens: simpleTokenizer(finalContent),\r\n                size: size,\r\n            };\r\n            this.copyInfo10History.push(this.lastCopiedInfo);\r\n            if (this.copyInfo10History.length > 10) {\r\n                this.copyInfo10History.shift();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// initialize the default watchdog instance\r\nconst watchdog = new Watchdog();\r\n\r\nexport default watchdog;\r\n", "import watchdog from './watchdog';\r\n\r\nconst scDetect: {\r\n    query: typeof watchdog.query;\r\n    initialize: typeof watchdog.initialize;\r\n    stop: typeof watchdog.stop;\r\n    queryAll: typeof watchdog.queryAll;\r\n    version: string;\r\n} = {\r\n    query: watchdog.query,\r\n    initialize: watchdog.initialize,\r\n    stop: watchdog.stop,\r\n    queryAll: watchdog.queryAll,\r\n    version: '1.0.0',\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n    (window as any).scDetect = scDetect;\r\n}\r\n\r\nexport default scDetect;"],
  "mappings": "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",
  "names": ["watchdog"]
}
