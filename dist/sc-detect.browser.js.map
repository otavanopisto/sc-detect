{
  "version": 3,
  "sources": ["../js/tokenizer.ts", "../js/ai.ts", "../js/watchdog.ts", "../js/index.ts"],
  "sourcesContent": ["const SIMPLE_TOKENIZER_CACHE: { [key: string]: string[] } = {};\r\nconst SIMPLE_TOKENIZER_CACHE_TIMEOUTS : { [key: string]: any } = {};\r\n\r\nexport function simpleTokenizer(input: string): string[] {\r\n    if (SIMPLE_TOKENIZER_CACHE[input]) {\r\n        clearTimeout(SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input]);\r\n        SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n            delete SIMPLE_TOKENIZER_CACHE[input];\r\n            delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n        }, 60000); // Cache timeout of 60 seconds\r\n        return SIMPLE_TOKENIZER_CACHE[input];\r\n    }\r\n\r\n    const tokens: string[] = [];\r\n    let currentToken = '';\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n        const char = input[i];\r\n\r\n        if (/\\s/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n        } else if (/[.,!?;:()]/.test(char)) {\r\n            if (currentToken) {\r\n                tokens.push(currentToken);\r\n                currentToken = '';\r\n            }\r\n            tokens.push(char);\r\n        } else {\r\n            currentToken += char;\r\n        }\r\n    }\r\n\r\n    if (currentToken) {\r\n        tokens.push(currentToken);\r\n    }\r\n\r\n    SIMPLE_TOKENIZER_CACHE[input] = tokens.map((token) => normalizeToken(token)).filter((token) => token.length > 0);\r\n\r\n    SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input] = setTimeout(() => {\r\n        delete SIMPLE_TOKENIZER_CACHE[input];\r\n        delete SIMPLE_TOKENIZER_CACHE_TIMEOUTS[input];\r\n    }, 60000); // Cache timeout of 60 seconds\r\n\r\n    return SIMPLE_TOKENIZER_CACHE[input];\r\n}\r\n\r\n// it should normalize tokens for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\nfunction normalizeToken(token: string): string {\r\n    const accentsMap: { [key: string]: string } = {\r\n        '\u00E1': 'a',\r\n        '\u00E9': 'e',\r\n        '\u00ED': 'i',\r\n        '\u00F3': 'o',\r\n        '\u00FA': 'u',\r\n        '\u00F1': 'n',\r\n        '\u00E4': 'a',\r\n        '\u00F6': 'o',\r\n        '\u00FC': 'u',\r\n    };\r\n\r\n    // normalize common prefixes and suffixes for languages like english, spanish, french, finnish, norwegian, swedish, german, dutch, etc...\r\n    const commonPrefixes = ['un', 're', 'in', 'im', 'dis', 'en', 'non', 'non-', 'pre', 'pre-', 'mis', 'sub', 'inter', 'fore', 'de', 'trans', 'super', 'semi', 'anti', 'mid', 'under'];\r\n    const commonSuffixes = ['s', 'es', 'ed', 'ing', 'ly', 'er', 'or', 'ion', 'tion', 'ation', 'ity', 'ment', 'ness', 'ful', 'less', 'est', 'ive', 'y', 'ize', 'ise', 'ify', 'en', 'ssa', 'lla', 'aa'];\r\n\r\n    for (const prefix of commonPrefixes) {\r\n        if (token.startsWith(prefix)) {\r\n            token = token.replace(prefix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    for (const suffix of commonSuffixes) {\r\n        if (token.endsWith(suffix)) {\r\n            token = token.replace(suffix, '');\r\n            break;\r\n        }\r\n    }\r\n\r\n    return token\r\n        .toLowerCase()\r\n        .replace(/[\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1\u00E4\u00F6\u00FC]/g, (match) => accentsMap[match] || match);\r\n}\r\n\r\n/**\r\n * Checks how similar two token arrays are and gives a score between 0 and 1.\r\n * @param tokensA \r\n * @param tokensB \r\n * @returns \r\n */\r\nexport function tokenSimilarityCompare(tokensA: string[], tokensB: string[]): number {\r\n    const setA = new Set(tokensA);\r\n    const setB = new Set(tokensB);\r\n\r\n    const intersection = new Set([...setA].filter(x => setB.has(x)));\r\n    const union = new Set([...setA, ...setB]);\r\n\r\n    return intersection.size / union.size;\r\n}\r\n\r\n/**\r\n * Checks what proportion of tokens in tokensContained are also in tokensContainer and gives a score between 0 and 1.\r\n * @param tokensContainer \r\n * @param tokensContained \r\n */\r\nexport function tokenContainmentCompare(tokensContainer: string[], tokensContained: string[]): number {\r\n    const setContainer = new Set(tokensContainer);\r\n    const setContained = new Set(tokensContained);\r\n\r\n    const intersection = new Set([...setContained].filter(x => setContainer.has(x)));\r\n\r\n    return intersection.size / setContained.size;\r\n}\r\n\r\nexport function tokenIncludesScore(tokensContainer: string[], tokensContained: string[], minimum_relevant: number): number {\r\n    // we need to look for exact sequences of tokensContained in tokensContainer in the same order as well as potential fragments\r\n    let score = 0;\r\n    // we will iterate over tokensContained to check each token as if it is found\r\n    for (let i = 0; i < tokensContained.length; i++) {\r\n        // find the token in tokensContainer\r\n        let thisTokenMaxScoreSoFar = 0;\r\n        // now we will iterate over tokensContainer to find matches\r\n        for (let j = 0; j < tokensContainer.length; j++) {\r\n            // check if tokensContainer[j] matches tokensContained[i]\r\n            if (tokensContainer[j] === tokensContained[i]) {\r\n                // now we need to see how many tokens match in sequence from this point\r\n                // we will calculate a score for this token match based on how many tokens match in sequence\r\n                let thisTokenScoreAtThisLocation = 0;\r\n                // we found a match, now let's check if the token is surrounded by the tokens before and after it that match as well\r\n                let matchLength = 0;\r\n                let matchMax = 0\r\n                // check backwards and forwards, seeing how well the surrounding tokens match\r\n                for (let k = -i; k < tokensContained.length - i; k++) {\r\n                    // the further away we go, the less weight it has, so we add a fraction of 1 based on how far we are from the center\r\n                    const potentialScoreAdded = 1 - (Math.abs(k) / tokensContained.length);\r\n                    matchMax += potentialScoreAdded;\r\n                    if (tokensContainer[j + k] === tokensContained[i + k]) {\r\n                        matchLength += potentialScoreAdded\r\n                    }\r\n                }\r\n\r\n                // calculate score for this token at this location\r\n                thisTokenScoreAtThisLocation = matchLength / matchMax;\r\n                \r\n                // see if it's the best score for this token so far\r\n                // use a max function to keep the best score\r\n                if (thisTokenScoreAtThisLocation > thisTokenMaxScoreSoFar) {\r\n                    thisTokenMaxScoreSoFar = thisTokenScoreAtThisLocation;\r\n                }\r\n            }\r\n        }\r\n\r\n        // add the best score for this token to the total score\r\n        score += thisTokenMaxScoreSoFar;\r\n    }\r\n\r\n    // average the score over the number of tokens contained\r\n    const finalScore = score / tokensContained.length;\r\n\r\n    // check if the final score is above the minimum relevant threshold\r\n    if (finalScore >= minimum_relevant) {\r\n        return finalScore;\r\n    }\r\n\r\n    return 0;\r\n}", "export function findAISignatures(text: string, treshold: number = 1): number {\r\n    // find ai signatures in the text that suggest it was generated by an ai language model\r\n    // for example em dashes\r\n    // emojis in the text\r\n    // certain phrases like \"as an ai language model\"\r\n    // numeration styles like \"1.\", \"2.\", \"3.\"\r\n    let score = 0;\r\n    const emDashCount = (text.match(/\u2014/g) || []).length;\r\n    score += emDashCount * 0.3;\r\n\r\n    const doubleMultiplierCount = (text.match(/\\*\\*/g) || []).length;\r\n    score += doubleMultiplierCount * 0.15;\r\n\r\n    // find emojis\r\n    const emojiCount = (text.match(/(?:\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F)(?:\\u200D(?:\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F))*|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}/gu) || []).length;\r\n    score += emojiCount * 0.5;\r\n\r\n    // find phrases\r\n    const aiPhrases = [\r\n        'as an ai language model',\r\n        'i am an ai',\r\n        'i am an artificial intelligence',\r\n        'as an artificial intelligence',\r\n        'chatgpt',\r\n        'gemini',\r\n        'claude'\r\n    ];\r\n    for (const phrase of aiPhrases) {\r\n        const phraseCount = (text.toLowerCase().match(new RegExp(phrase, 'g')) || []).length;\r\n        score += phraseCount * 1;\r\n    }\r\n\r\n    // find numeration styles\r\n    const numerationCount = (text.match(/\\b\\d+\\./g) || []).length;\r\n    score += numerationCount * 0.05;\r\n\r\n    if (score > treshold) {\r\n        return 1\r\n    }\r\n    return 0;\r\n}", "import { simpleTokenizer, tokenContainmentCompare, tokenIncludesScore, tokenSimilarityCompare } from \"./tokenizer\";\r\nimport { findAISignatures } from \"./ai\";\r\n\r\n/**\r\n * Watchdog module to monitor copy-paste behavior and tab switching\r\n * to detect potential cheating\r\n * \r\n * weights:\r\n *  - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: weight for the factor that measures\r\n *    how much the user keeps switching tabs and copy-pasting\r\n *  - COPY_RELATES_TO_PASTE: weight for the factor that measures how much\r\n *   the copy events relate to the paste events\r\n *  - CONTENT_CONTAINS_AI_SIGNATURES: weight for the factor that measures\r\n *   how much the content contains AI signatures\r\n *  - UNMODIFIED_PASTES: weight for the factor that measures how much\r\n *  the pastes are unmodified\r\n * \r\n * min_copy_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * min_tab_event_time_weight: minimum weight for the time factor, the closer it is to the time limit, the minimum weight is applied\r\n * \r\n * Keep the weights summing to 1.0 in order to have a proper confidence score\r\n * between 0 and 1.0\r\n * \r\n * Note that a confidence score close to 1.0 does not necessarily mean cheating,\r\n * but rather a high likelihood of cheating behavior based on the monitored factors.\r\n * A human review is still recommended for high confidence scores.\r\n * \r\n * paste_size_threshold: minimum size of pasted content to consider\r\n * copy_size_threshold: minimum size of copied content to consider\r\n * settings:\r\n *  - relevant_copy_event_minutes: time window in minutes to consider\r\n *    copy events as relevant to paste events\r\n *  - relevant_tab_in_out_event_minutes: time window in minutes to consider\r\n *    tab in/out events as relevant to copy-paste behavior\r\n */\r\nexport interface WatchdogConfig {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number,\r\n            COPY_RELATES_TO_PASTE: number,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: number,\r\n            UNMODIFIED_PASTES: number,\r\n        },\r\n        min_copy_event_time_weight: number,\r\n        min_tab_event_time_weight: number,\r\n    },\r\n    paste_size_threshold: number,\r\n    copy_size_threshold: number,\r\n    settings: {\r\n        relevant_copy_event_minutes: number;\r\n        relevant_tab_in_out_event_minutes: number;\r\n    }\r\n}\r\n\r\n/**\r\n * The default configuration for the Watchdog module\r\n */\r\nconst DEFAULT_CONFIG: WatchdogConfig = {\r\n    weights: {\r\n        reasons: {\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0.3,\r\n            COPY_RELATES_TO_PASTE: 0.3,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0.2,\r\n            UNMODIFIED_PASTES: 0.1,\r\n        },\r\n        min_copy_event_time_weight: 0.5,\r\n        min_tab_event_time_weight: 0.5,\r\n    },\r\n    paste_size_threshold: 30,\r\n    copy_size_threshold: 30,\r\n    settings: {\r\n        relevant_copy_event_minutes: 5,\r\n        relevant_tab_in_out_event_minutes: 5,\r\n    }\r\n}\r\n\r\n/**\r\n * Factors that influence the Watchdog analysis\r\n * - deadline: time remaining until the deadline in minutes, if zero or negative, no deadline\r\n * - caught_rate: rate of previous cheating detections for the user, between 0 and 1\r\n * - non_native_language: whether the user is using a non-native language for the test\r\n */\r\nexport interface WatchdogFactors {\r\n    deadline: number,\r\n    caught_rate: number,\r\n    non_native_language: boolean,\r\n}\r\n\r\n/**\r\n * The default factors for the Watchdog module\r\n * - deadline: 0 (no deadline)\r\n * - caught_rate: 0 (no previous cheating detections)\r\n * - non_native_language: false (native language)\r\n */\r\nconst DEFAULT_FACTORS: WatchdogFactors = {\r\n    deadline: 0,\r\n    caught_rate: 0,\r\n    non_native_language: false,\r\n}\r\n\r\n/**\r\n * Interface for copy-paste contribution objects\r\n */\r\nexport interface CopyPasteContribution {\r\n    /**\r\n     * AI signature score for the pasted content, a number between 0 and 1 on whether the content has AI signatures\r\n     */\r\n    aiScore: number;\r\n    /**\r\n     * Cheating paste score based on similarity and related copy/tab switch events, a number between 0 and 1\r\n     */\r\n    pasteScore: number;\r\n    /**\r\n     * Final score for this contribution, a number between 0 and 1, the maximum between aiScore and pasteScore\r\n     */\r\n    score: number;\r\n    /**\r\n     * Timestamp of the paste event\r\n     */\r\n    timestamp: Date;\r\n    /**\r\n     * Similarity between copied and pasted content, a number between 0 and 1\r\n     */\r\n    similarity: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the content of the tokens, a number between 0 and 1\r\n     */\r\n    containment: number;\r\n    /**\r\n     * Factor how much a paste is related to a copy event, based on the time and tab switching, a number between 0 and 1\r\n     */\r\n    copyFactor: number;\r\n    /**\r\n     * Factor how much a paste is related to a tab switch event, based on the time, a number between 0 and 1\r\n     */\r\n    tabSwitchFactor: number;\r\n    /**\r\n     * Content of the pasted text\r\n     */\r\n    content: string;\r\n}\r\n\r\n/**\r\n * State interface for each WatchdogHandle, each one represents a monitored input element or textarea\r\n * - COPY_PASTE_CONTRIBUTIONS: array of copy-paste contribution objects\r\n * - COPY_RELATES_TO_PASTE: score for the factor that measures how much copy events relate to paste events\r\n * - CONTENT_CONTAINS_AI_SIGNATURES: score for the factor that measures how much the content contains AI signatures\r\n * - UNMODIFIED_PASTES: score for the factor that measures how much the pastes are unmodified\r\n * - KEEPS_SWITCHING_TABS_AND_COPY_PASTING: score for the factor that measures how much the user keeps switching tabs and copy-pasting\r\n * \r\n * All factors are between 0 and 1, the final confidence score is calculated\r\n * by weighting each factor according to the weights defined in the WatchdogConfig\r\n */\r\nexport interface WatchdogHandleState {\r\n    COPY_PASTE_CONTRIBUTIONS: Array<CopyPasteContribution>;\r\n    COPY_RELATES_TO_PASTE: number;\r\n    CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n    UNMODIFIED_PASTES: number;\r\n    KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n}\r\n\r\nexport type WatchdogStateLoader = () => Promise<WatchdogHandleState>;\r\n\r\nclass WatchdogHandle {\r\n    element: HTMLElement;\r\n    watchdog: Watchdog;\r\n    isInitialized: boolean = false;\r\n    state: WatchdogHandleState;\r\n    loadStateLoader: WatchdogStateLoader | null = null;\r\n    listeners: Array<(analysis: IWatchdogAnalysis) => void> = [];\r\n    //shouldBeAttemptedToProcessAsInputDiff: boolean = false;\r\n    //lastInputValue: string = \"\";\r\n    //selectionWhilePaste: string = \"\";\r\n\r\n    constructor(element: HTMLElement, watchdog: Watchdog) {\r\n        this.element = element;\r\n        this.watchdog = watchdog;\r\n        this.state = {\r\n            COPY_PASTE_CONTRIBUTIONS: [],\r\n            // INPUT_CONTRIBUTIONS: [],\r\n\r\n            COPY_RELATES_TO_PASTE: 0,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: 0,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: 0,\r\n            UNMODIFIED_PASTES: 0,\r\n        };\r\n\r\n        this.handlePaste = this.handlePaste.bind(this);\r\n        this.handleInput = this.handleInput.bind(this);\r\n    }\r\n    setStateLoader(fn: WatchdogStateLoader) {\r\n        this.loadStateLoader = fn;\r\n    }\r\n    async initialize() {\r\n        if (!this.watchdog.isMonitoring) {\r\n            throw new Error('Watchdog is not initialized. Please call scDetect.initialize() first.');\r\n        }\r\n        this.isInitialized = true;\r\n        // make sure that is in an input with contenteditable or textarea or input type=text\r\n        const tagName = this.element.tagName.toLowerCase();\r\n        const type = (this.element as HTMLInputElement).type;\r\n        if (tagName === 'textarea' || (tagName === 'input' && type === 'text') || this.element.isContentEditable) {\r\n            // Start monitoring the element for copy-paste and tab switch events\r\n            // Implementation of monitoring logic goes here\r\n            await this.loadState();\r\n            this.restart();\r\n        } else {\r\n            throw new Error('Element is not a valid input field (textarea, input type=text, or contenteditable).');\r\n        }\r\n    }\r\n    async loadState() {\r\n        // Implementation of loadState method for this handle\r\n        // Load any saved state from this.state\r\n        if (this.loadStateLoader) {\r\n            this.state = await this.loadStateLoader();\r\n        }\r\n\r\n        // TODO other loading mechanisms can be added here\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n        this.onNewScoreCalculated();\r\n    }\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    restart() {\r\n        if (!this.isInitialized) {\r\n            throw new Error('WatchdogHandle is not initialized. Please call initialize() first.');\r\n        }\r\n        \r\n        //this.lastInputValue = this.getContentFromHTMLElement();\r\n\r\n        // Implementation of restart method for this handle\r\n        // add event listeners to paste, input\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput as any);\r\n        this.element.addEventListener('paste', this.handlePaste);\r\n        this.element.addEventListener('input', this.handleInput as any);\r\n    }\r\n    stop() {\r\n        // Implementation of stop method for this handle\r\n        this.isInitialized = false;\r\n\r\n        // remove all event listeners\r\n        this.element.removeEventListener('paste', this.handlePaste);\r\n        this.element.removeEventListener('input', this.handleInput as any);\r\n    }\r\n    destroy() {\r\n        // Implementation of destroy method for this handle\r\n        this.stop();\r\n        // Additional cleanup\r\n        this.watchdog.handles = this.watchdog.handles.filter(h => h !== this);\r\n    }\r\n    handleInput(e: InputEvent) {\r\n        //if (e.inputType === \"insertFromPaste\" && this.shouldBeAttemptedToProcessAsInputDiff) {\r\n        //    this.shouldBeAttemptedToProcessAsInputDiff = false;\r\n\r\n        //    const originalText = this.lastInputValue.replace(this.selectionWhilePaste, '');\r\n        //    const currentText = this.getContentFromHTMLElement();\r\n\r\n        //    let newText = \"\"\r\n        //    let startIndex = 0;\r\n        //    let endIndex = currentText.length - 1;\r\n\r\n            // we want to move this cursor through the originalText and currentText and find where they differ to set our start index\r\n        //    while (startIndex < originalText.length && startIndex < currentText.length && originalText[startIndex] === currentText[startIndex]) {\r\n        //        startIndex++;\r\n        //    }\r\n            // now we do the same from the end to find the end index\r\n        //    while (endIndex >= 0 && endIndex >= startIndex && originalText[originalText.length - 1 - (currentText.length - 1 - endIndex)] === currentText[endIndex]) {\r\n        //        endIndex--;\r\n        //    }\r\n\r\n        //    if (endIndex >= startIndex) {\r\n        //        newText = currentText.substring(startIndex, endIndex + 1);\r\n        //        console.log(newText);\r\n        //        this.handlePastedText(newText);\r\n        //    }\r\n\r\n        //}\r\n\r\n        this.recalculateCopyRelatesToPaste();\r\n        this.recalculateAIScore();\r\n        this.recalculateUnmodifiedPastes();\r\n        this.recalculateKeepsSwitchingTabsAndCopyPasting();\r\n        this.onNewScoreCalculated();\r\n\r\n        //this.lastInputValue = this.getContentFromHTMLElement();\r\n    }\r\n    /**\r\n     * If you want to refresh the internal input value\r\n     * Because you have some external code modifying the input value\r\n     * programmatically rather than the user typing or pasting, please\r\n     * call this method to update the internal state.\r\n     */\r\n    //refreshInternalInputValue() {\r\n    //    this.lastInputValue = this.getContentFromHTMLElement();\r\n    //}\r\n    handlePaste(e: ClipboardEvent) {\r\n        const clipboardData = e.clipboardData;\r\n        if (!clipboardData) {\r\n            return;\r\n        }\r\n        const text = clipboardData.getData('text/plain');\r\n\r\n        if (!text) {\r\n            //this.shouldBeAttemptedToProcessAsInputDiff = true;\r\n            //this.selectionWhilePaste = document.getSelection()?.toString() || \"\";\r\n            return;\r\n        }\r\n\r\n        // check if it fits the paste size threshold\r\n        if (text.length < this.watchdog.config.paste_size_threshold) {\r\n            return;\r\n        }\r\n\r\n        this.handlePastedText(text);\r\n    }\r\n\r\n    handlePastedText(text: string) {\r\n        const tokens = simpleTokenizer(text);\r\n        const similarity = tokenSimilarityCompare(tokens, this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : []);\r\n        const containment = this.watchdog.lastCopiedInfo?.tokens.length ? tokenContainmentCompare(tokens, this.watchdog.lastCopiedInfo ? this.watchdog.lastCopiedInfo.tokens : []) : 0;\r\n\r\n        // similarities too high are likely modified pastes, so we just ignore them\r\n        if (similarity > 0.9) {\r\n            return;\r\n        }\r\n\r\n        // Now lets look for a copy event, followed by a tabout event, followed by this paste event\r\n        // within a reasonable time frame (e.g., 5 minutes)\r\n        const now = new Date();\r\n        let foundRelatedCopy = false;\r\n        let foundRelatedCopyTimeFactor = 0;\r\n        let switchedTabsRecently = false;\r\n        let switchedTabsRecentlyTimeFactor = 0;\r\n\r\n        if (this.watchdog.lastCopiedInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.lastCopiedInfo.timestamp.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000) {\r\n                foundRelatedCopy = true;\r\n                foundRelatedCopyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_copy_event_minutes * 60 * 1000));\r\n                if (foundRelatedCopyTimeFactor < this.watchdog.config.weights.min_copy_event_time_weight) {\r\n                    foundRelatedCopyTimeFactor = this.watchdog.config.weights.min_copy_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.watchdog.activeTabFocusInfo) {\r\n            const timeDiff = now.getTime() - this.watchdog.activeTabFocusInfo.focused_in.getTime();\r\n            if (timeDiff < this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000) {\r\n                switchedTabsRecently = true;\r\n                switchedTabsRecentlyTimeFactor = 1 - (timeDiff / (this.watchdog.config.settings.relevant_tab_in_out_event_minutes * 60 * 1000));\r\n                if (switchedTabsRecentlyTimeFactor < this.watchdog.config.weights.min_tab_event_time_weight) {\r\n                    switchedTabsRecentlyTimeFactor = this.watchdog.config.weights.min_tab_event_time_weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        const foundRelatedCopyFactor = (foundRelatedCopy ? 1 : 0) * foundRelatedCopyTimeFactor;\r\n        const switchedTabsRecentlyFactor = (switchedTabsRecently ? 1 : 0) * switchedTabsRecentlyTimeFactor;\r\n        // the cheating paste score is the average of the three factors\r\n        // we weight equally the containment, as in if the pasted content relates to copied content and by how much it relates\r\n        // and the foundRelatedCopyFactor and switchedTabsRecentlyFactor, which are time-weighted factors indicating recent related copy and tab switch events\r\n        const cheatingPasteScore = containment * foundRelatedCopyFactor * switchedTabsRecentlyFactor;\r\n        let score = cheatingPasteScore;\r\n\r\n        // we also check for AI signatures in the pasted content\r\n        const aiScore = findAISignatures(text, 1);\r\n\r\n        // if aiScore is higher than cheatingPasteScore, we use that as the score\r\n        if (aiScore >= cheatingPasteScore) {\r\n            score *= aiScore;\r\n        }\r\n\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.push({\r\n            pasteScore: cheatingPasteScore,\r\n            score: score,\r\n            aiScore: aiScore,\r\n            timestamp: now,\r\n            similarity: similarity,\r\n            containment: containment,\r\n            copyFactor: foundRelatedCopyFactor,\r\n            tabSwitchFactor: switchedTabsRecentlyFactor,\r\n            content: text,\r\n        });\r\n    }\r\n    private recalculateCopyRelatesToPaste() {\r\n        // calculate average score, guarding against empty contributions array\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.COPY_RELATES_TO_PASTE = 0;\r\n        } else {\r\n            // we average the scores of all contributions\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.score;\r\n            })\r\n            this.state.COPY_RELATES_TO_PASTE = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateAIScore() {\r\n        if (this.state.COPY_PASTE_CONTRIBUTIONS.length === 0) {\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = 0;\r\n        } else {\r\n            let total = 0;\r\n            const currentContent = this.getContentFromHTMLElement();\r\n            this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n                // let's see how much of the content out of the current content is made of copied content\r\n                const tokenIncludesScoreValue = tokenIncludesScore(simpleTokenizer(currentContent), simpleTokenizer(contribution.content), 0.7);\r\n                total += tokenIncludesScoreValue * contribution.aiScore;\r\n            })\r\n            this.state.CONTENT_CONTAINS_AI_SIGNATURES = total / this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n        }\r\n    }\r\n    private recalculateUnmodifiedPastes() {\r\n        // recalculate unmodified pastes factor\r\n        let unmodifiedPastes = 0;\r\n        const totalPastes = this.state.COPY_PASTE_CONTRIBUTIONS.length;\r\n\r\n        if (totalPastes === 0) {\r\n            this.state.UNMODIFIED_PASTES = 0;\r\n            return;\r\n        }\r\n\r\n        let contentWorking = this.getContentFromHTMLElement();\r\n        this.state.COPY_PASTE_CONTRIBUTIONS.forEach((contribution) => {\r\n            if (contentWorking.includes(contribution.content)) {\r\n                unmodifiedPastes++;\r\n                // remove the pasted content from the working content to avoid double counting\r\n                contentWorking = contentWorking.replace(contribution.content, '');\r\n            } else {\r\n                // find a match sentence by sentence\r\n                const sentences = contribution.content.split(/(?<=[.!?])\\s+|\\n|\\r\\n/).filter(s => s.trim().length > 0);\r\n                let localUnmodifiedPastes = 0;\r\n                for (const sentence of sentences) {\r\n                    if (contentWorking.includes(sentence)) {\r\n                        localUnmodifiedPastes++;\r\n                        // remove the pasted content from the working content to avoid double counting\r\n                        contentWorking = contentWorking.replace(sentence, '');\r\n                    }\r\n                }\r\n                unmodifiedPastes += localUnmodifiedPastes / sentences.length;\r\n            }\r\n        });\r\n\r\n        const unmodifiedPastesRatio = unmodifiedPastes / totalPastes;\r\n        const remainingCharacters = contentWorking.length;\r\n        const totalCharacters = this.getContentFromHTMLElement().length;\r\n        const remainingCharactersRatio = totalCharacters > 0 ? remainingCharacters / totalCharacters : 0;\r\n\r\n        // combine both ratios to get a final unmodified pastes score\r\n        const finalUnmodifiedPastesScore = (unmodifiedPastesRatio + (1 - remainingCharactersRatio)) / 2;\r\n\r\n        this.state.UNMODIFIED_PASTES = finalUnmodifiedPastesScore;  \r\n    }\r\n    private recalculateKeepsSwitchingTabsAndCopyPasting() {\r\n        // recalculate keeps switching tabs and copy pasting factor\r\n        // for that we will look for an ever alternating pattern of tab switches followed by a paste event\r\n        let switchingTabAndCopyPastingScore = 0;\r\n        let totalPatterns = 0;\r\n\r\n        // first let's loop in the tab focus history to find tab switches\r\n        const tabFocusHistoryWithCurrent: TabFocusWatchInfo[] = [...this.watchdog.tabFocusWatchInfoHistory, this.watchdog.activeTabFocusInfo] as TabFocusWatchInfo[];\r\n\r\n        if (tabFocusHistoryWithCurrent.length < 2) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const currentContent = this.getContentFromHTMLElement();\r\n        const currentContentTokens = simpleTokenizer(currentContent);\r\n        for (let i = 1; i < tabFocusHistoryWithCurrent.length; i++) {\r\n            const current = tabFocusHistoryWithCurrent[i];\r\n            const next = tabFocusHistoryWithCurrent[i + 1];\r\n\r\n            // find one or more paste events between current.focused_out and next.focused_out so we can assume that it was a tab switch followed by a paste, if the\r\n            // next has no focused_out, we use now as the end time\r\n            const endTime = next && next.focused_out ? next.focused_out : new Date();\r\n            const startTime = current.focused_out ? current.focused_out : current.focused_in;\r\n\r\n            const pastesInBetween = this.state.COPY_PASTE_CONTRIBUTIONS.filter(contribution => {\r\n                return contribution.timestamp >= startTime && contribution.timestamp <= endTime;\r\n            });\r\n            if (pastesInBetween.length > 0) {\r\n                totalPatterns++;\r\n                let maxScoreOfAPaste = 0;\r\n                pastesInBetween.forEach((contribution) => {\r\n                    let actualScore = 0;\r\n                    // we need to check against the current content\r\n                    // to see if the pasted content is included in the current content\r\n                    // in one way or another\r\n                    const tokenIncludesScoreValue = tokenIncludesScore(currentContentTokens, simpleTokenizer(contribution.content), 0.7);\r\n                    actualScore = tokenIncludesScoreValue * contribution.score;\r\n                    if (actualScore > maxScoreOfAPaste) {\r\n                        maxScoreOfAPaste = actualScore;\r\n                    }\r\n                });\r\n                switchingTabAndCopyPastingScore += maxScoreOfAPaste;\r\n            }\r\n        }\r\n\r\n        if (totalPatterns === 0) {\r\n            this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = 0;\r\n            return;\r\n        }\r\n\r\n        const finalScore = switchingTabAndCopyPastingScore / totalPatterns;\r\n        this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING = finalScore;\r\n    }\r\n    getCurrentAISignatureScore() {\r\n        // get the current value as text from the\r\n        return findAISignatures(this.getContentFromHTMLElement(), 1);\r\n    }\r\n    getContentFromHTMLElement() {\r\n        // get the value of the input field, textarea or contenteditable\r\n        if (this.element.tagName.toLowerCase() === 'textarea' || (this.element.tagName.toLowerCase() === 'input' && (this.element as HTMLInputElement).type === 'text')) {\r\n            return (this.element as HTMLInputElement).value;\r\n        } else if (this.element.isContentEditable) {\r\n            return this.element.innerText;\r\n        }\r\n        return '';\r\n    }\r\n    getLastAnalysis(): IWatchdogAnalysis {\r\n        // we need to reweight these factors based on the config weights\r\n        const WEIGHTED = {\r\n            COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE*this.watchdog.config.weights.reasons.COPY_RELATES_TO_PASTE,\r\n            CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES*this.watchdog.config.weights.reasons.CONTENT_CONTAINS_AI_SIGNATURES,\r\n            UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES*this.watchdog.config.weights.reasons.UNMODIFIED_PASTES,\r\n            KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING*this.watchdog.config.weights.reasons.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n\r\n        return {\r\n            raw: {\r\n                COPY_RELATES_TO_PASTE: this.state.COPY_RELATES_TO_PASTE,\r\n                CONTENT_CONTAINS_AI_SIGNATURES: this.state.CONTENT_CONTAINS_AI_SIGNATURES,\r\n                UNMODIFIED_PASTES: this.state.UNMODIFIED_PASTES,\r\n                KEEPS_SWITCHING_TABS_AND_COPY_PASTING: this.state.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n            },\r\n            weighted: WEIGHTED,\r\n            confidence: WEIGHTED.COPY_RELATES_TO_PASTE +\r\n                WEIGHTED.CONTENT_CONTAINS_AI_SIGNATURES +\r\n                WEIGHTED.UNMODIFIED_PASTES +\r\n                WEIGHTED.KEEPS_SWITCHING_TABS_AND_COPY_PASTING,\r\n        };\r\n    }\r\n    private onNewScoreCalculated() {\r\n        // placeholder for future event handling when a new score is calculated\r\n        const analysis = this.getLastAnalysis();\r\n        this.listeners.forEach((listener) => {\r\n            listener(analysis);\r\n        });\r\n    }\r\n    public addEventListenerOnNewScoreCalculated(callback: (analysis: IWatchdogAnalysis) => void) {\r\n        this.listeners.push(callback);\r\n    }\r\n    public removeEventListenerOnNewScoreCalculated(callback: (analysis: IWatchdogAnalysis) => void) {\r\n        this.listeners = this.listeners.filter(listener => listener !== callback);\r\n    }\r\n}\r\n\r\nexport interface IWatchdogAnalysis {\r\n    raw: {\r\n        COPY_RELATES_TO_PASTE: number;\r\n        CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n        UNMODIFIED_PASTES: number;\r\n        KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n    };\r\n    weighted: {\r\n        COPY_RELATES_TO_PASTE: number;\r\n        CONTENT_CONTAINS_AI_SIGNATURES: number;\r\n        UNMODIFIED_PASTES: number;\r\n        KEEPS_SWITCHING_TABS_AND_COPY_PASTING: number;\r\n    };\r\n    confidence: number;\r\n}\r\n\r\nexport interface TabFocusWatchInfo {\r\n    focused_in: Date;\r\n    focused_out?: Date;\r\n    duration_ms?: number;\r\n    gap_ms: number;\r\n    is_focused: boolean;\r\n}\r\n\r\nexport interface CopiedInfo {\r\n    timestamp: Date;\r\n    content: string;\r\n    tokens: string[];\r\n    size: number;\r\n}\r\n\r\n/**\r\n * Watchdog class to monitor copy-paste behavior and tab switching\r\n * this is the base class that manages the monitoring and analysis\r\n */\r\nclass Watchdog {\r\n    /**\r\n     * Configuration for the Watchdog module\r\n     */\r\n    config: WatchdogConfig;\r\n    /**\r\n     * Factors influencing the Watchdog's analysis\r\n     */\r\n    factors: WatchdogFactors;\r\n    /**\r\n     * Indicates whether the Watchdog is currently monitoring\r\n     */\r\n    isMonitoring: boolean = false;\r\n    /**\r\n     * Array of WatchdogHandle instances being monitored these\r\n     * represent the monitored input elements or textareas\r\n     */\r\n    handles: WatchdogHandle[] = [];\r\n    /**\r\n     * User ID being monitored\r\n     */\r\n    userId: string | null = null;\r\n    \r\n    /**\r\n     * Tab focus watch info history and active tab focus info\r\n     * keeping track of when the tab was focused and unfocused\r\n     * does not include the current active tab focus info\r\n     */\r\n    tabFocusWatchInfoHistory: TabFocusWatchInfo[] = [];\r\n    /**\r\n     * Active tab focus info representing the current tab focus state\r\n     */\r\n    activeTabFocusInfo: TabFocusWatchInfo | null = null;\r\n\r\n    /**\r\n     * Last copied info event\r\n     */\r\n    lastCopiedInfo: CopiedInfo | null = null;\r\n    /**\r\n     * History of last 10 copied info events, it includes the lastCopiedInfo as the last element\r\n     */\r\n    copyInfo10History: CopiedInfo[] = [];\r\n\r\n    /**\r\n     * Constructor for the Watchdog class\r\n     */\r\n    constructor() {\r\n        // Initialization code\r\n        this.config = DEFAULT_CONFIG;\r\n        this.factors = DEFAULT_FACTORS;\r\n        this.userId = null;\r\n\r\n        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\r\n        this.handleCopy = this.handleCopy.bind(this);\r\n        this.query = this.query.bind(this);\r\n        this.queryAll = this.queryAll.bind(this);\r\n        this.initialize = this.initialize.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.changeUser = this.changeUser.bind(this);\r\n        this.beginMonitoring = this.beginMonitoring.bind(this);\r\n    }\r\n\r\n    /**\r\n     * query an element to monitor, use a CSS selector to pick this element or provide the element directly\r\n     * @param selector \r\n     * @returns \r\n     */\r\n    query(selector: string | HTMLElement) {\r\n        // Implementation of query method\r\n        const element = typeof selector === \"string\" ? document.querySelectorAll(selector) : [selector];\r\n        // check that only one element is found\r\n        if (element.length !== 1) {\r\n            throw new Error(`Expected one element for selector \"${selector}\", but found ${element.length}.`);\r\n        }\r\n        const handle = new WatchdogHandle(element[0] as HTMLElement, this);\r\n        this.handles.push(handle);\r\n        return handle;\r\n    }\r\n    /**\r\n     * Query all elements matching the selector to monitor, use a CSS selector to pick these elements\r\n     * otherwise provide an array of elements directly\r\n     * @param selector \r\n     */\r\n    queryAll(selector: string | HTMLElement[]) {\r\n        // Implementation of queryAll method\r\n        const elements = typeof selector === \"string\" ? document.querySelectorAll(selector) : selector;\r\n        return Array.from(elements).map((el) => {\r\n            const handle = new WatchdogHandle(el as HTMLElement, this);\r\n            this.handles.push(handle);\r\n            return handle;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * initialize the Watchdog module, this needs to be called before starting monitoring\r\n     * otherwise an error will be thrown when trying to monitor elements, as the configuration\r\n     * and factors will not be set; you can re-initialize to change user or configuration on the fly\r\n     * \r\n     * @param userId \r\n     * @param config \r\n     * @param factors \r\n     */\r\n    initialize(\r\n        userId: string,\r\n        config?: Partial<WatchdogConfig>,\r\n        factors?: Partial<WatchdogFactors>,\r\n    ) {\r\n        // Implementation of initialize method\r\n        // patch DEFAULT_CONFIG and DEFAULT_FACTORS with provided config and factors\r\n        this.config = { ...DEFAULT_CONFIG, ...config };\r\n        this.factors = { ...DEFAULT_FACTORS, ...factors };\r\n        this.userId = userId;\r\n\r\n        if (!this.isMonitoring) {\r\n            this.beginMonitoring();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * stop the Watchdog monitoring\r\n     */\r\n    stop() {\r\n        // Implementation of stop method\r\n        this.isMonitoring = false;\r\n        this.handles.forEach((handle) => handle.stop());\r\n\r\n        document.removeEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.removeEventListener('copy', this.handleCopy);\r\n    }\r\n\r\n    /**\r\n     * Change the user being monitored, stops and restarts monitoring for the new user\r\n     * \r\n     * @param userId \r\n     */\r\n    changeUser(userId: string) {\r\n        // Implementation of changeUser method\r\n        this.userId = userId;\r\n        this.stop();\r\n        this.handles.forEach((handle) => handle.loadState());\r\n        this.beginMonitoring();\r\n    }\r\n\r\n    /**\r\n     * Begin monitoring for copy-paste and tab switching events\r\n     */\r\n    beginMonitoring() {\r\n        // Implementation of beginMonitoring method\r\n        this.isMonitoring = true;\r\n\r\n        this.activeTabFocusInfo = {\r\n            focused_in: new Date(),\r\n            gap_ms: 0,\r\n            is_focused: true,\r\n        };\r\n        this.tabFocusWatchInfoHistory = []\r\n        this.lastCopiedInfo = null;\r\n        this.copyInfo10History = [];\r\n\r\n        document.addEventListener('visibilitychange', this.handleVisibilityChange);\r\n        document.addEventListener('copy', this.handleCopy);\r\n        \r\n        this.handles.forEach((handle) => {\r\n            if (handle.isInitialized) {\r\n                handle.restart();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle visibility change events to track tab focus and unfocus\r\n     */\r\n    handleVisibilityChange() {\r\n        if (document.hidden && this.activeTabFocusInfo) {\r\n            this.activeTabFocusInfo.focused_out = new Date();\r\n            this.activeTabFocusInfo.duration_ms = this.activeTabFocusInfo.focused_out.getTime() - this.activeTabFocusInfo.focused_in.getTime();\r\n            this.activeTabFocusInfo.is_focused = false;\r\n            this.tabFocusWatchInfoHistory.push(this.activeTabFocusInfo);\r\n            this.activeTabFocusInfo = null;\r\n        } else {\r\n            const lastFocusInfo = this.tabFocusWatchInfoHistory.length > 0 ? this.tabFocusWatchInfoHistory[this.tabFocusWatchInfoHistory.length - 1] : null;\r\n            const gap_ms = lastFocusInfo && lastFocusInfo.focused_out ? (new Date().getTime() - lastFocusInfo.focused_out.getTime()) : 0;\r\n            this.activeTabFocusInfo = {\r\n                focused_in: new Date(),\r\n                gap_ms: gap_ms,\r\n                is_focused: true,\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle copy events to track copied content\r\n     */\r\n    handleCopy(event: ClipboardEvent) {\r\n        const clipboardData = event.clipboardData;\r\n        if (clipboardData) {\r\n            const content = clipboardData.getData('text/plain');\r\n            const selectedText = window.getSelection()?.toString() || '';\r\n            const finalContent = content || selectedText;\r\n            if (!finalContent) {\r\n                return;\r\n            }\r\n            const size = finalContent.length;\r\n            // check if it fits the copy size threshold\r\n            if (size < this.config.copy_size_threshold) {\r\n                return;\r\n            }\r\n            this.lastCopiedInfo = {\r\n                timestamp: new Date(),\r\n                content: finalContent,\r\n                tokens: simpleTokenizer(finalContent),\r\n                size: size,\r\n            };\r\n            this.copyInfo10History.push(this.lastCopiedInfo);\r\n            if (this.copyInfo10History.length > 10) {\r\n                this.copyInfo10History.shift();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// initialize the default watchdog instance\r\nconst watchdog = new Watchdog();\r\n\r\nexport default watchdog;\r\n", "import watchdog from './watchdog';\r\n\r\nconst scDetect: {\r\n    query: typeof watchdog.query;\r\n    initialize: typeof watchdog.initialize;\r\n    stop: typeof watchdog.stop;\r\n    queryAll: typeof watchdog.queryAll;\r\n    version: string;\r\n} = {\r\n    query: watchdog.query,\r\n    initialize: watchdog.initialize,\r\n    stop: watchdog.stop,\r\n    queryAll: watchdog.queryAll,\r\n    version: '1.0.0',\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n    (window as any).scDetect = scDetect;\r\n}\r\n\r\nexport default scDetect;"],
  "mappings": "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",
  "names": ["watchdog"]
}
